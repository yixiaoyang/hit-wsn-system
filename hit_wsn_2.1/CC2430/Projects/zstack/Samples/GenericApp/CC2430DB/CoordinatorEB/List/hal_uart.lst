###############################################################################
#                                                                             #
# IAR 8051 C/C++ Compiler V7.30B/W32                    07/Jun/2011  16:48:46 #
# Copyright 2004-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  E:\嵌入式开发\hit-wsn\src\hit_wsn_2.1\hit_wsn_2.1\ #
#                          CC2430\Components\hal\target\CC2430EB\hal_uart.c   #
#    Command line       =  -f E:\嵌入式开发\hit-wsn\src\hit_wsn_2.1\hit_wsn_2 #
#                          .1\CC2430\Projects\zstack\Samples\GenericApp\CC243 #
#                          0DB\..\..\..\Tools\CC2430DB\f8wCoord.cfg           #
#                          (-DCPU32MHZ -DFORCE_MAC_NEAR -DROOT=__near_func    #
#                          -DMAC_CFG_APP_PENDING_QUEUE=TRUE                   #
#                          -DZDO_COORDINATOR -DRTR_NWK -DBLINK_LEDS           #
#                          "-DCONST=const __code" -DGENERIC=__generic) -f     #
#                          E:\嵌入式开发\hit-wsn\src\hit_wsn_2.1\hit_wsn_2.1\ #
#                          CC2430\Projects\zstack\Samples\GenericApp\CC2430DB #
#                          \..\..\..\Tools\CC2430DB\f8wConfig.cfg             #
#                          (-DSECURE=0 -DDEFAULT_CHANLIST=0x00000800          #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=10 -DAPSC_MAX_FRAME_RETRIES=3   #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=20           #
#                          -DNWK_MAX_BINDING_ENTRIES=10                       #
#                          -DMAX_BINDING_CLUSTER_IDS=5 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 E:\嵌入式开发\hit-wsn\src\h #
#                          it_wsn_2.1\hit_wsn_2.1\CC2430\Components\hal\targe #
#                          t\CC2430EB\hal_uart.c -D CC2430EB -D REFLECTOR -D  #
#                          ZTOOL_P1 -D MT_TASK -D xMT_ZDO_FUNC -D             #
#                          LCD_SUPPORTED=DEBUG -lC E:\嵌入式开发\hit-wsn\src\ #
#                          hit_wsn_2.1\hit_wsn_2.1\CC2430\Projects\zstack\Sam #
#                          ples\GenericApp\CC2430DB\CoordinatorEB\List\ -lA   #
#                          E:\嵌入式开发\hit-wsn\src\hit_wsn_2.1\hit_wsn_2.1\ #
#                          CC2430\Projects\zstack\Samples\GenericApp\CC2430DB #
#                          \CoordinatorEB\List\ --diag_suppress Pe001,Pa010   #
#                          --diag_remark pe550 -o E:\嵌入式开发\hit-wsn\src\h #
#                          it_wsn_2.1\hit_wsn_2.1\CC2430\Projects\zstack\Samp #
#                          les\GenericApp\CC2430DB\CoordinatorEB\Obj\ -e -z9  #
#                          --no_code_motion --debug --core=plain --dptr=16,1  #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data --nr_virtual_regs 8 -I      #
#                          E:\嵌入式开发\hit-wsn\src\hit_wsn_2.1\hit_wsn_2.1\ #
#                          CC2430\Projects\zstack\Samples\GenericApp\CC2430DB #
#                          \ -I E:\嵌入式开发\hit-wsn\src\hit_wsn_2.1\hit_wsn #
#                          _2.1\CC2430\Projects\zstack\Samples\GenericApp\CC2 #
#                          430DB\..\SOURCE\ -I E:\嵌入式开发\hit-wsn\src\hit_ #
#                          wsn_2.1\hit_wsn_2.1\CC2430\Projects\zstack\Samples #
#                          \GenericApp\CC2430DB\..\..\..\ZMAIN\TI2430DB\ -I   #
#                          E:\嵌入式开发\hit-wsn\src\hit_wsn_2.1\hit_wsn_2.1\ #
#                          CC2430\Projects\zstack\Samples\GenericApp\CC2430DB #
#                          \..\..\..\..\..\COMPONENTS\MT\ -I                  #
#                          E:\嵌入式开发\hit-wsn\src\hit_wsn_2.1\hit_wsn_2.1\ #
#                          CC2430\Projects\zstack\Samples\GenericApp\CC2430DB #
#                          \..\..\..\..\..\COMPONENTS\HAL\INCLUDE\ -I         #
#                          E:\嵌入式开发\hit-wsn\src\hit_wsn_2.1\hit_wsn_2.1\ #
#                          CC2430\Projects\zstack\Samples\GenericApp\CC2430DB #
#                          \..\..\..\..\..\COMPONENTS\HAL\TARGET\CC2430EB\    #
#                          -I E:\嵌入式开发\hit-wsn\src\hit_wsn_2.1\hit_wsn_2 #
#                          .1\CC2430\Projects\zstack\Samples\GenericApp\CC243 #
#                          0DB\..\..\..\..\..\COMPONENTS\OSAL\MCU\CCSOC\ -I   #
#                          E:\嵌入式开发\hit-wsn\src\hit_wsn_2.1\hit_wsn_2.1\ #
#                          CC2430\Projects\zstack\Samples\GenericApp\CC2430DB #
#                          \..\..\..\..\..\COMPONENTS\OSAL\INCLUDE\ -I        #
#                          E:\嵌入式开发\hit-wsn\src\hit_wsn_2.1\hit_wsn_2.1\ #
#                          CC2430\Projects\zstack\Samples\GenericApp\CC2430DB #
#                          \..\..\..\..\..\COMPONENTS\STACK\AF\ -I            #
#                          E:\嵌入式开发\hit-wsn\src\hit_wsn_2.1\hit_wsn_2.1\ #
#                          CC2430\Projects\zstack\Samples\GenericApp\CC2430DB #
#                          \..\..\..\..\..\COMPONENTS\STACK\NWK\ -I           #
#                          E:\嵌入式开发\hit-wsn\src\hit_wsn_2.1\hit_wsn_2.1\ #
#                          CC2430\Projects\zstack\Samples\GenericApp\CC2430DB #
#                          \..\..\..\..\..\COMPONENTS\STACK\SEC\ -I           #
#                          E:\嵌入式开发\hit-wsn\src\hit_wsn_2.1\hit_wsn_2.1\ #
#                          CC2430\Projects\zstack\Samples\GenericApp\CC2430DB #
#                          \..\..\..\..\..\COMPONENTS\STACK\SYS\ -I           #
#                          E:\嵌入式开发\hit-wsn\src\hit_wsn_2.1\hit_wsn_2.1\ #
#                          CC2430\Projects\zstack\Samples\GenericApp\CC2430DB #
#                          \..\..\..\..\..\COMPONENTS\STACK\ZDO\ -I           #
#                          E:\嵌入式开发\hit-wsn\src\hit_wsn_2.1\hit_wsn_2.1\ #
#                          CC2430\Projects\zstack\Samples\GenericApp\CC2430DB #
#                          \..\..\..\..\..\COMPONENTS\ZMAC\F8W\ -I            #
#                          E:\嵌入式开发\hit-wsn\src\hit_wsn_2.1\hit_wsn_2.1\ #
#                          CC2430\Projects\zstack\Samples\GenericApp\CC2430DB #
#                          \..\..\..\..\..\COMPONENTS\ZMAC\ -I                #
#                          E:\嵌入式开发\hit-wsn\src\hit_wsn_2.1\hit_wsn_2.1\ #
#                          CC2430\Projects\zstack\Samples\GenericApp\CC2430DB #
#                          \..\..\..\..\..\COMPONENTS\SERVICES\SADDR\ -I      #
#                          E:\嵌入式开发\hit-wsn\src\hit_wsn_2.1\hit_wsn_2.1\ #
#                          CC2430\Projects\zstack\Samples\GenericApp\CC2430DB #
#                          \..\..\..\..\..\COMPONENTS\SERVICES\SDATA\ -I      #
#                          E:\嵌入式开发\hit-wsn\src\hit_wsn_2.1\hit_wsn_2.1\ #
#                          CC2430\Projects\zstack\Samples\GenericApp\CC2430DB #
#                          \..\..\..\..\..\COMPONENTS\MAC\INCLUDE\ -I         #
#                          E:\嵌入式开发\hit-wsn\src\hit_wsn_2.1\hit_wsn_2.1\ #
#                          CC2430\Projects\zstack\Samples\GenericApp\CC2430DB #
#                          \..\..\..\..\..\COMPONENTS\MAC\HIGH_LEVEL\ -I      #
#                          E:\嵌入式开发\hit-wsn\src\hit_wsn_2.1\hit_wsn_2.1\ #
#                          CC2430\Projects\zstack\Samples\GenericApp\CC2430DB #
#                          \..\..\..\..\..\COMPONENTS\MAC\LOW_LEVEL\SRF03\    #
#                          -I E:\嵌入式开发\hit-wsn\src\hit_wsn_2.1\hit_wsn_2 #
#                          .1\CC2430\Projects\zstack\Samples\GenericApp\CC243 #
#                          0DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LEVEL\SRF03\ #
#                          SINGLE_CHIP\ -I "D:\Program Files\IAR              #
#                          Systems\Embedded Workbench 4.0 Evaluation          #
#                          version\8051\INC\" -I "D:\Program Files\IAR        #
#                          Systems\Embedded Workbench 4.0 Evaluation          #
#                          version\8051\INC\CLIB\"                            #
#    List file          =  E:\嵌入式开发\hit-wsn\src\hit_wsn_2.1\hit_wsn_2.1\ #
#                          CC2430\Projects\zstack\Samples\GenericApp\CC2430DB #
#                          \CoordinatorEB\List\hal_uart.lst                   #
#    Object file        =  E:\嵌入式开发\hit-wsn\src\hit_wsn_2.1\hit_wsn_2.1\ #
#                          CC2430\Projects\zstack\Samples\GenericApp\CC2430DB #
#                          \CoordinatorEB\Obj\hal_uart.r51                    #
#                                                                             #
#                                                                             #
###############################################################################

E:\嵌入式开发\hit-wsn\src\hit_wsn_2.1\hit_wsn_2.1\CC2430\Components\hal\target\CC2430EB\hal_uart.c
      1          /**************************************************************************************************
      2            Filename:       _hal_uart.c
      3            Revised:        $Date: 2007-11-01 08:44:53 -0700 (Thu, 01 Nov 2007) $
      4            Revision:       $Revision: 15821 $
      5          
      6            Description: This file contains the interface to the H/W UART driver.
      7          
      8          
      9            Copyright 2006-2007 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, 
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com. 
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          
     44          #include "hal_types.h"
     45          #include "hal_assert.h"
     46          #include "hal_board.h"

   \                                 In  segment SFR_AN, at 0x80
   \   union <unnamed> volatile __sfr _A_P0
   \                     _A_P0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x86
   \   unsigned char volatile __sfr U0CSR
   \                     U0CSR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x90
   \   union <unnamed> volatile __sfr _A_P1
   \                     _A_P1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x95
   \   unsigned char volatile __sfr ST0
   \                     ST0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc1
   \   unsigned char volatile __sfr U0DBUF
   \                     U0DBUF:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc2
   \   unsigned char volatile __sfr U0BAUD
   \                     U0BAUD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc4
   \   unsigned char volatile __sfr U0UCR
   \                     U0UCR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc5
   \   unsigned char volatile __sfr U0GCR
   \                     U0GCR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd1
   \   unsigned char volatile __sfr DMAIRQ
   \                     DMAIRQ:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd6
   \   unsigned char volatile __sfr DMAARM
   \                     DMAARM:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd7
   \   unsigned char volatile __sfr DMAREQ
   \                     DMAREQ:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf1
   \   unsigned char volatile __sfr PERCFG
   \                     PERCFG:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf2
   \   unsigned char volatile __sfr ADCCFG
   \                     ADCCFG:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf3
   \   unsigned char volatile __sfr P0SEL
   \                     P0SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfd
   \   unsigned char volatile __sfr P0DIR
   \                     P0DIR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xff
   \   unsigned char volatile __sfr P2DIR
   \                     P2DIR:
   \   000000                DS 1
     47          #include "hal_defs.h"
     48          #if defined( HAL_UART_DMA ) && HAL_UART_DMA
     49            #include "hal_dma.h"
     50          #endif
     51          #include "hal_mcu.h"
     52          #include "hal_uart.h"
     53          #include "osal.h"
     54          
     55          /*********************************************************************
     56           * MACROS
     57           */
     58          
     59          #if !defined ( HAL_UART_DEBUG )
     60            #define HAL_UART_DEBUG  FALSE
     61          #endif
     62          
     63          #if !defined ( HAL_UART_CLOSE )
     64            #define HAL_UART_CLOSE  FALSE
     65          #endif
     66          
     67          #if !defined ( HAL_UART_BIG_TX_BUF )
     68            #define HAL_UART_BIG_TX_BUF  FALSE
     69          #endif
     70          
     71          /*
     72           *  The MAC_ASSERT macro is for use during debugging.
     73           *  The given expression must evaluate as "true" or else fatal error occurs.
     74           *  At that point, the call stack feature of the debugger can pinpoint where
     75           *  the problem occurred.
     76           *
     77           *  To disable this feature and save code size, the project should define
     78           *  HAL_UART_DEBUG to FALSE.
     79           */
     80          #if ( HAL_UART_DEBUG )
     81            #define HAL_UART_ASSERT( expr)        HAL_ASSERT( expr )
     82          #else
     83            #define HAL_UART_ASSERT( expr )
     84          #endif
     85          
     86          #define P2DIR_PRIPO               0xC0
     87          #if HAL_UART_0_ENABLE
     88            #define HAL_UART_PRIPO          0x00
     89          #else
     90            #define HAL_UART_PRIPO          0x40
     91          #endif
     92          
     93          #define HAL_UART_0_PERCFG_BIT     0x01  // USART0 on P0, so clear this bit.
     94          #define HAL_UART_0_P0_RX_TX       0x0c  // Peripheral I/O Select for Rx/Tx.
     95          #define HAL_UART_0_P0_RTS         0x10  // Peripheral I/O Select for RTS.
     96          #define HAL_UART_0_P0_CTS         0x20  // Peripheral I/O Select for CTS.
     97          
     98          #define HAL_UART_1_PERCFG_BIT     0x02  // USART1 on P1, so set this bit.
     99          #define HAL_UART_1_P1_RTS         0x10  // Peripheral I/O Select for RTS.
    100          #define HAL_UART_1_P1_CTS         0x20  // Peripheral I/O Select for CTS.
    101          #define HAL_UART_1_P1_RX_TX       0xC0  // Peripheral I/O Select for Rx/Tx.
    102          
    103          #define TX_AVAIL( cfg ) \
    104            ((cfg->txTail == cfg->txHead) ? (cfg->txMax-1) : \
    105            ((cfg->txTail >  cfg->txHead) ? (cfg->txTail - cfg->txHead - 1) : \
    106                               (cfg->txMax - cfg->txHead + cfg->txTail)))
    107          
    108          #define RX0_FLOW_ON  ( P0 &= ~HAL_UART_0_P0_CTS )
    109          #define RX0_FLOW_OFF ( P0 |= HAL_UART_0_P0_CTS )
    110          #define RX1_FLOW_ON  ( P1 &= ~HAL_UART_1_P1_CTS)
    111          #define RX1_FLOW_OFF ( P1 |= HAL_UART_1_P1_CTS )
    112          
    113          #define RX_STOP_FLOW( cfg ) { \
    114            if ( !(cfg->flag & UART_CFG_U1F) ) \
    115            { \
    116              RX0_FLOW_OFF; \
    117            } \
    118            else \
    119            { \
    120              RX1_FLOW_OFF; \
    121            } \
    122            if ( cfg->flag & UART_CFG_DMA ) \
    123            { \
    124              cfg->rxTick = DMA_RX_DLY; \
    125            } \
    126            cfg->flag |= UART_CFG_RXF; \
    127          }
    128          
    129          #define RX_STRT_FLOW( cfg ) { \
    130            if ( !(cfg->flag & UART_CFG_U1F) ) \
    131            { \
    132              RX0_FLOW_ON; \
    133            } \
    134            else \
    135            { \
    136              RX1_FLOW_ON; \
    137            } \
    138            cfg->flag &= ~UART_CFG_RXF; \
    139          }
    140          
    141          #define UART_RX_AVAIL( cfg ) \
    142            ( (cfg->rxHead >= cfg->rxTail) ? (cfg->rxHead - cfg->rxTail) : \
    143                                             (cfg->rxMax - cfg->rxTail + cfg->rxHead +1 ) )
    144          
    145          /* Need to leave enough of the Rx buffer free to handle the incoming bytes
    146           * after asserting flow control, but before the transmitter has obeyed it.
    147           * At the max expected baud rate of 115.2k, 16 bytes will only take ~1.3 msecs,
    148           * but at the min expected baud rate of 38.4k, they could take ~4.2 msecs.
    149           * SAFE_RX_MIN and DMA_RX_DLY must both be consistent according to
    150           * the min & max expected baud rate.
    151           */
    152          #if !defined( SAFE_RX_MIN )
    153            #define SAFE_RX_MIN  48  // bytes - max expected per poll @ 115.2k
    154            // 16 bytes @ 38.4 kBaud -> 4.16 msecs -> 138 32-kHz ticks.
    155            #define DMA_RX_DLY  140
    156            //  2 bytes @ 38.4 kBaud -> 0.52 msecs ->  17 32-kHz ticks.
    157            #define DMA_TX_DLY   20
    158          #endif
    159          
    160          // The timeout tick is at 32-kHz, so multiply msecs by 33.
    161          #define RX_MSECS_TO_TICKS  33
    162          
    163          // The timeout only supports 1 byte.
    164          #if !defined( HAL_UART_RX_IDLE )
    165            #define HAL_UART_RX_IDLE  (6 * RX_MSECS_TO_TICKS)
    166          #endif
    167          
    168          // Only supporting 1 of the 2 USART modules to be driven by DMA at a time.
    169          #if HAL_UART_DMA == 1
    170            #define DMATRIG_RX  HAL_DMA_TRIG_URX0
    171            #define DMATRIG_TX  HAL_DMA_TRIG_UTX0
    172            #define DMA_UDBUF   HAL_DMA_U0DBUF
    173            #define DMA_PAD     U0BAUD
    174          #elif HAL_UART_DMA == 2
    175            #define DMATRIG_RX  HAL_DMA_TRIG_URX1
    176            #define DMATRIG_TX  HAL_DMA_TRIG_UTX1
    177            #define DMA_UDBUF   HAL_DMA_U1DBUF
    178            #define DMA_PAD     U1BAUD
    179          #endif
    180          
    181          #define DMA_RX( cfg ) { \
    182            volatile uint8 ft2430 = U0DBUF; \
    183            \
    184            halDMADesc_t *ch = HAL_DMA_GET_DESC1234( HAL_DMA_CH_RX ); \
    185            \
    186            HAL_DMA_SET_DEST( ch, cfg->rxBuf ); \
    187            \
    188            HAL_DMA_SET_LEN( ch, cfg->rxMax ); \
    189            \
    190            HAL_DMA_CLEAR_IRQ( HAL_DMA_CH_RX ); \
    191            \
    192            HAL_DMA_ARM_CH( HAL_DMA_CH_RX ); \
    193          }
    194          
    195          #define DMA_TX( cfg ) { \
    196            halDMADesc_t *ch = HAL_DMA_GET_DESC1234( HAL_DMA_CH_TX ); \
    197            \
    198            HAL_DMA_SET_SOURCE( ch, (cfg->txBuf + cfg->txTail) ); \
    199            \
    200            HAL_DMA_SET_LEN( ch, cfg->txCnt ); \
    201            \
    202            HAL_DMA_CLEAR_IRQ( HAL_DMA_CH_TX ); \
    203            \
    204            HAL_DMA_ARM_CH( HAL_DMA_CH_TX ); \
    205            \
    206            HAL_DMA_START_CH( HAL_DMA_CH_TX ); \
    207          }
    208          
    209          /*********************************************************************
    210           * TYPEDEFS
    211           */
    212          
    213          typedef struct
    214          {
    215            uint8 *rxBuf;
    216            uint8 rxHead;
    217            uint8 rxTail;
    218            uint8 rxMax;
    219            uint8 rxCnt;
    220            uint8 rxTick;
    221            uint8 rxHigh;
    222          
    223            uint8 *txBuf;
    224          #if HAL_UART_BIG_TX_BUF
    225            uint16 txHead;
    226            uint16 txTail;
    227            uint16 txMax;
    228            uint16 txCnt;
    229          #else
    230            uint8 txHead;
    231            uint8 txTail;
    232            uint8 txMax;
    233            uint8 txCnt;
    234          #endif
    235            uint8 txTick;
    236          
    237            uint8 flag;
    238          
    239            halUARTCBack_t rxCB;
    240          } uartCfg_t;
    241          
    242          /*********************************************************************
    243           * CONSTANTS
    244           */
    245          
    246          // Used by DMA macros to shift 1 to create a mask for DMA registers.
    247          #define HAL_DMA_CH_TX    3
    248          #define HAL_DMA_CH_RX    4
    249          
    250          #define HAL_DMA_U0DBUF  0xDFC1
    251          #define HAL_DMA_U1DBUF  0xDFF9
    252          
    253          // UxCSR - USART Control and Status Register.
    254          #define CSR_MODE      0x80
    255          #define CSR_RE        0x40
    256          #define CSR_SLAVE     0x20
    257          #define CSR_FE        0x10
    258          #define CSR_ERR       0x08
    259          #define CSR_RX_BYTE   0x04
    260          #define CSR_TX_BYTE   0x02
    261          #define CSR_ACTIVE    0x01
    262          
    263          // UxUCR - USART UART Control Register.
    264          #define UCR_FLUSH     0x80
    265          #define UCR_FLOW      0x40
    266          #define UCR_D9        0x20
    267          #define UCR_BIT9      0x10
    268          #define UCR_PARITY    0x08
    269          #define UCR_SPB       0x04
    270          #define UCR_STOP      0x02
    271          #define UCR_START     0x01
    272          
    273          #define UTX0IE        0x04
    274          #define UTX1IE        0x08
    275          
    276          #define UART_CFG_U1F  0x80  // USART1 flag bit.
    277          #define UART_CFG_DMA  0x40  // Port is using DMA.
    278          #define UART_CFG_FLW  0x20  // Port is using flow control.
    279          #define UART_CFG_SP4  0x10
    280          #define UART_CFG_SP3  0x08
    281          #define UART_CFG_SP2  0x04
    282          #define UART_CFG_RXF  0x02  // Rx flow is disabled.
    283          #define UART_CFG_TXF  0x01  // Tx is in process.
    284          
    285          /*********************************************************************
    286           * GLOBAL VARIABLES
    287           */
    288          
    289          /*********************************************************************
    290           * GLOBAL FUNCTIONS
    291           */
    292          
    293          /*********************************************************************
    294           * LOCAL VARIABLES
    295           */
    296          
    297          #if HAL_UART_0_ENABLE

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    298          uartCfg_t *cfg0;
   \                     cfg0:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    299          #endif
    300          #if HAL_UART_1_ENABLE
    301          static uartCfg_t *cfg1;
    302          #endif
    303          
    304          /*********************************************************************
    305           * LOCAL FUNCTIONS
    306           */
    307          
    308          #if HAL_UART_DMA
    309          static void pollDMA( uartCfg_t *cfg );
    310          #endif
    311          #if HAL_UART_ISR
    312          static void pollISR( uartCfg_t *cfg );
    313          #endif
    314          
    315          #if HAL_UART_DMA
    316          /******************************************************************************
    317           * @fn      pollDMA
    318           *
    319           * @brief   Poll a USART module implemented by DMA.
    320           *
    321           * @param   cfg - USART configuration structure.
    322           *
    323           * @return  none
    324           *****************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    325          static void pollDMA( uartCfg_t *cfg )
   \                     pollDMA:
    326          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
    327            const uint8 cnt = cfg->rxHead;
   \   00000E   EE           MOV     A,R6
   \   00000F   2402         ADD     A,#0x2
   \   000011   0A           INC     R2
   \   000012   0A           INC     R2
   \   000013   12....       LCALL   ?Subroutine4 & 0xFFFF
    328            uint8 *pad = cfg->rxBuf+(cfg->rxHead*2);
   \                     ??CrossCallReturnLabel_9:
   \   000016   C3           CLR     C
   \   000017   33           RLC     A
   \   000018   F8           MOV     R0,A
   \   000019   E4           CLR     A
   \   00001A   33           RLC     A
   \   00001B   F9           MOV     R1,A
   \   00001C   8E82         MOV     DPL,R6
   \   00001E   8F83         MOV     DPH,R7
   \   000020   E0           MOVX    A,@DPTR
   \   000021   28           ADD     A,R0
   \   000022   F8           MOV     R0,A
   \   000023   A3           INC     DPTR
   \   000024   E0           MOVX    A,@DPTR
   \   000025   39           ADDC    A,R1
   \   000026   8035         SJMP    ??pollDMA_0
    329          
    330            // Pack the received bytes to the front of the queue.
    331            while ( (*pad == DMA_PAD) && (cfg->rxHead < cfg->rxMax) )
    332            {
    333              cfg->rxBuf[cfg->rxHead++] = *(pad+1);
   \                     ??pollDMA_1:
   \   000028   EE           MOV     A,R6
   \   000029   2402         ADD     A,#0x2
   \   00002B   FA           MOV     R2,A
   \   00002C   8882         MOV     DPL,R0
   \   00002E   8983         MOV     DPH,R1
   \   000030   A3           INC     DPTR
   \   000031   E0           MOVX    A,@DPTR
   \   000032   C0E0         PUSH    A
   \   000034   8A82         MOV     DPL,R2
   \   000036   8B83         MOV     DPH,R3
   \   000038   E0           MOVX    A,@DPTR
   \   000039   F5..         MOV     ?V0 + 0,A
   \   00003B   8E82         MOV     DPL,R6
   \   00003D   8F83         MOV     DPH,R7
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   25..         ADD     A,?V0 + 0
   \   000042   FD           MOV     R5,A
   \   000043   A3           INC     DPTR
   \   000044   E0           MOVX    A,@DPTR
   \   000045   3400         ADDC    A,#0x0
   \   000047   8D82         MOV     DPL,R5
   \   000049   F583         MOV     DPH,A
   \   00004B   D0E0         POP     A
   \   00004D   F0           MOVX    @DPTR,A
   \   00004E   8A82         MOV     DPL,R2
   \   000050   8B83         MOV     DPH,R3
   \   000052   E0           MOVX    A,@DPTR
   \   000053   04           INC     A
   \   000054   F0           MOVX    @DPTR,A
    334              pad += 2;
   \   000055   E8           MOV     A,R0
   \   000056   2402         ADD     A,#0x2
   \   000058   08           INC     R0
   \   000059   08           INC     R0
   \   00005A   E9           MOV     A,R1
   \   00005B   3400         ADDC    A,#0x0
   \                     ??pollDMA_0:
   \   00005D   F9           MOV     R1,A
    335            }
   \   00005E   8882         MOV     DPL,R0
   \   000060   8983         MOV     DPH,R1
   \   000062   E0           MOVX    A,@DPTR
   \   000063   65C2         XRL     A,0xc2
   \   000065   7019         JNZ     ??pollDMA_2
   \   000067   8E82         MOV     DPL,R6
   \   000069   8F83         MOV     DPH,R7
   \   00006B   A3           INC     DPTR
   \   00006C   A3           INC     DPTR
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   C0E0         PUSH    A
   \   000070   8E82         MOV     DPL,R6
   \   000072   8F83         MOV     DPH,R7
   \   000074   A3           INC     DPTR
   \   000075   A3           INC     DPTR
   \   000076   A3           INC     DPTR
   \   000077   A3           INC     DPTR
   \   000078   E0           MOVX    A,@DPTR
   \   000079   FA           MOV     R2,A
   \   00007A   D0E0         POP     A
   \   00007C   C3           CLR     C
   \   00007D   9A           SUBB    A,R2
   \   00007E   40A8         JC      ??pollDMA_1
    336          
    337            if ( !(cfg->flag & UART_CFG_RXF) )
   \                     ??pollDMA_2:
   \   000080   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   000083   A2E1         MOV     C,0xE0 /* A   */.1
   \   000085   8E82         MOV     DPL,R6
   \   000087   8F83         MOV     DPH,R7
   \   000089   A3           INC     DPTR
   \   00008A   A3           INC     DPTR
   \   00008B   4042         JC      ??pollDMA_3
    338            {
    339              /* It is necessary to stop Rx flow and wait for H/W-enqueued bytes still
    340               * incoming to stop before resetting the DMA Rx engine. If DMA Rx is
    341               * aborted during incoming data, a byte may be lost inside the engine
    342               * during the 2-step transfer process of read/write.
    343               */
    344              if ( cfg->rxHead >= (cfg->rxMax - SAFE_RX_MIN) )
   \   00008D   E0           MOVX    A,@DPTR
   \   00008E   FA           MOV     R2,A
   \   00008F   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   000092   4023         JC      ??pollDMA_4
    345              {
    346                RX_STOP_FLOW( cfg );
   \   000094   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   000097   4004         JC      ??pollDMA_5
   \   000099   D285         SETB    0x80.5
   \   00009B   8002         SJMP    ??pollDMA_6
   \                     ??pollDMA_5:
   \   00009D   D295         SETB    0x90.5
   \                     ??pollDMA_6:
   \   00009F   A2E6         MOV     C,0xE0 /* A   */.6
   \   0000A1   500D         JNC     ??pollDMA_7
   \   0000A3   748C         MOV     A,#-0x74
   \   0000A5   8E82         MOV     DPL,R6
   \   0000A7   8F83         MOV     DPH,R7
   \   0000A9   A3           INC     DPTR
   \   0000AA   A3           INC     DPTR
   \   0000AB   A3           INC     DPTR
   \   0000AC   A3           INC     DPTR
   \   0000AD   A3           INC     DPTR
   \   0000AE   A3           INC     DPTR
   \   0000AF   F0           MOVX    @DPTR,A
   \                     ??pollDMA_7:
   \   0000B0   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   0000B3   D2E1         SETB    0xE0 /* A   */.1
   \   0000B5   8057         SJMP    ??pollDMA_8
    347              }
    348              // If anything received, reset the Rx idle timer.
    349              else if ( cfg->rxHead != cnt )
   \                     ??pollDMA_4:
   \   0000B7   8E82         MOV     DPL,R6
   \   0000B9   8F83         MOV     DPH,R7
   \   0000BB   A3           INC     DPTR
   \   0000BC   A3           INC     DPTR
   \   0000BD   E0           MOVX    A,@DPTR
   \   0000BE   6C           XRL     A,R4
   \   0000BF   604E         JZ      ??pollDMA_9
    350              {
    351                cfg->rxTick = HAL_UART_RX_IDLE;
   \   0000C1   74C6         MOV     A,#-0x3a
   \   0000C3   8E82         MOV     DPL,R6
   \   0000C5   8F83         MOV     DPH,R7
   \   0000C7   A3           INC     DPTR
   \   0000C8   A3           INC     DPTR
   \   0000C9   A3           INC     DPTR
   \   0000CA   A3           INC     DPTR
   \   0000CB   A3           INC     DPTR
   \   0000CC   A3           INC     DPTR
   \   0000CD   803F         SJMP    ??pollDMA_8
    352              }
    353            }
    354            else if ( !cfg->rxTick && (cfg->rxHead == cfg->rxTail) )
   \                     ??pollDMA_3:
   \   0000CF   A3           INC     DPTR
   \   0000D0   A3           INC     DPTR
   \   0000D1   A3           INC     DPTR
   \   0000D2   A3           INC     DPTR
   \   0000D3   E0           MOVX    A,@DPTR
   \   0000D4   7039         JNZ     ??pollDMA_9
   \   0000D6   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   0000D9   7034         JNZ     ??pollDMA_9
    355            {
    356              HAL_DMA_ABORT_CH( HAL_DMA_CH_RX );
   \   0000DB   75D690       MOV     0xd6,#-0x70
    357              cfg->rxHead = cfg->rxTail = 0;
   \   0000DE   12....       LCALL   ?Subroutine16 & 0xFFFF
    358              osal_memset( cfg->rxBuf, ~DMA_PAD, cfg->rxMax*2 );
   \                     ??CrossCallReturnLabel_49:
   \   0000E1   2404         ADD     A,#0x4
   \   0000E3   F5..         MOV     ?V0 + 0,A
   \   0000E5   EF           MOV     A,R7
   \   0000E6   3400         ADDC    A,#0x0
   \   0000E8   F5..         MOV     ?V0 + 1,A
   \   0000EA                ; Setup parameters for call to function osal_memset
   \   0000EA   85..82       MOV     DPL,?V0 + 0
   \   0000ED   F583         MOV     DPH,A
   \   0000EF   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   0000F2   A3           INC     DPTR
   \   0000F3   E0           MOVX    A,@DPTR
   \   0000F4   FB           MOV     R3,A
   \   0000F5   12....       LCALL   ?Subroutine10 & 0xFFFF
    359              DMA_RX( cfg );
   \                     ??CrossCallReturnLabel_39:
   \   0000F8   85..82       MOV     DPL,?V0 + 0
   \   0000FB   85..83       MOV     DPH,?V0 + 1
   \   0000FE   12....       LCALL   ?Subroutine8 & 0xFFFF
    360              RX_STRT_FLOW( cfg );
   \                     ??CrossCallReturnLabel_35:
   \   000101   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   000104   4004         JC      ??pollDMA_10
   \   000106   C285         CLR     0x80.5
   \   000108   8002         SJMP    ??pollDMA_11
   \                     ??pollDMA_10:
   \   00010A   C295         CLR     0x90.5
   \                     ??pollDMA_11:
   \   00010C   C2E1         CLR     0xE0 /* A   */.1
   \                     ??pollDMA_8:
   \   00010E   F0           MOVX    @DPTR,A
    361            }
    362          
    363            if ( HAL_DMA_CHECK_IRQ( HAL_DMA_CH_TX ) )
   \                     ??pollDMA_9:
   \   00010F   E5D1         MOV     A,0xd1
   \   000111   A2E3         MOV     C,0xE0 /* A   */.3
   \   000113   5048         JNC     ??pollDMA_12
    364            {
    365              HAL_DMA_CLEAR_IRQ( HAL_DMA_CH_TX );
   \   000115   53D1F7       ANL     0xd1,#0xf7
    366              cfg->flag &= ~UART_CFG_TXF;
   \   000118   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   00011B   C2E0         CLR     0xE0 /* A   */.0
   \   00011D   F0           MOVX    @DPTR,A
    367              cfg->txTick = DMA_TX_DLY;
   \   00011E   EE           MOV     A,R6
   \   00011F   240E         ADD     A,#0xe
   \   000121   12....       LCALL   ??Subroutine21_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   000124   7414         MOV     A,#0x14
   \   000126   F0           MOVX    @DPTR,A
    368          
    369              if ( (cfg->txMax - cfg->txCnt) < cfg->txTail )
   \   000127   EE           MOV     A,R6
   \   000128   240C         ADD     A,#0xc
   \   00012A   12....       LCALL   ??Subroutine7_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_19:
   \   00012D   F8           MOV     R0,A
   \   00012E   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   000131   E8           MOV     A,R0
   \   000132   C3           CLR     C
   \   000133   9A           SUBB    A,R2
   \   000134   F8           MOV     R0,A
   \   000135   E4           CLR     A
   \   000136   9400         SUBB    A,#0x0
   \   000138   F9           MOV     R1,A
   \   000139   EE           MOV     A,R6
   \   00013A   240B         ADD     A,#0xb
   \   00013C   12....       LCALL   ??Subroutine2_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   00013F   C3           CLR     C
   \   000140   E8           MOV     A,R0
   \   000141   9A           SUBB    A,R2
   \   000142   E9           MOV     A,R1
   \   000143   9400         SUBB    A,#0x0
   \   000145   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000147   65D0         XRL     A,PSW
   \   000149   33           RLC     A
   \   00014A   5005         JNC     ??pollDMA_13
    370              {
    371                cfg->txTail = 0;  // DMA can only run to the end of the Tx buffer.
   \   00014C   E4           CLR     A
   \                     ??pollDMA_14:
   \   00014D   F0           MOVX    @DPTR,A
   \   00014E   02....       LJMP    ??pollDMA_15 & 0xFFFF
    372              }
    373              else
    374              {
    375                cfg->txTail += cfg->txCnt;
   \                     ??pollDMA_13:
   \   000151   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   000154   EE           MOV     A,R6
   \   000155   240B         ADD     A,#0xb
   \   000157   12....       LCALL   ??Subroutine7_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_20:
   \   00015A   2A           ADD     A,R2
   \   00015B   80F0         SJMP    ??pollDMA_14
    376              }
    377            }
    378            else if ( !(cfg->flag & UART_CFG_TXF) && !cfg->txTick )
   \                     ??pollDMA_12:
   \   00015D   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_21:
   \   000160   A2E0         MOV     C,0xE0 /* A   */.0
   \   000162   5003         JNC     $+5
   \   000164   02....       LJMP    ??pollDMA_15 & 0xFFFF
   \   000167   EE           MOV     A,R6
   \   000168   240E         ADD     A,#0xe
   \   00016A   12....       LCALL   ??Subroutine7_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   00016D   6003         JZ      $+5
   \   00016F   02....       LJMP    ??pollDMA_15 & 0xFFFF
    379            {
    380              if ( cfg->txTail != cfg->txHead )
   \   000172   EE           MOV     A,R6
   \   000173   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_70:
   \   000176   6A           XRL     A,R2
   \   000177   7003         JNZ     $+5
   \   000179   02....       LJMP    ??pollDMA_15 & 0xFFFF
    381              {
    382                if ( cfg->txTail < cfg->txHead )
   \   00017C   EE           MOV     A,R6
   \   00017D   240B         ADD     A,#0xb
   \   00017F   12....       LCALL   ??Subroutine7_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   000182   C0E0         PUSH    A
   \   000184   8E82         MOV     DPL,R6
   \   000186   8F83         MOV     DPH,R7
   \   000188   A3           INC     DPTR
   \   000189   A3           INC     DPTR
   \   00018A   A3           INC     DPTR
   \   00018B   A3           INC     DPTR
   \   00018C   A3           INC     DPTR
   \   00018D   A3           INC     DPTR
   \   00018E   A3           INC     DPTR
   \   00018F   A3           INC     DPTR
   \   000190   A3           INC     DPTR
   \   000191   A3           INC     DPTR
   \   000192   E0           MOVX    A,@DPTR
   \   000193   FA           MOV     R2,A
   \   000194   D0E0         POP     A
   \   000196   C3           CLR     C
   \   000197   9A           SUBB    A,R2
   \   000198   EE           MOV     A,R6
   \   000199   5007         JNC     ??pollDMA_16
    383                {
    384                  cfg->txCnt = cfg->txHead - cfg->txTail;
   \   00019B   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_71:
   \   00019E   C3           CLR     C
   \   00019F   9A           SUBB    A,R2
   \   0001A0   800E         SJMP    ??pollDMA_17
    385                }
    386                else  // Can only run DMA engine up to max, then restart at zero.
    387                {
    388                  cfg->txCnt = cfg->txMax - cfg->txTail + 1;
   \                     ??pollDMA_16:
   \   0001A2   240B         ADD     A,#0xb
   \   0001A4   12....       LCALL   ??Subroutine2_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   0001A7   EE           MOV     A,R6
   \   0001A8   240C         ADD     A,#0xc
   \   0001AA   12....       LCALL   ??Subroutine7_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   0001AD   C3           CLR     C
   \   0001AE   9A           SUBB    A,R2
   \   0001AF   04           INC     A
   \                     ??pollDMA_17:
   \   0001B0   C0E0         PUSH    A
   \   0001B2   EE           MOV     A,R6
   \   0001B3   240D         ADD     A,#0xd
   \   0001B5   12....       LCALL   ??Subroutine21_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   0001B8   D0E0         POP     A
   \   0001BA   F0           MOVX    @DPTR,A
    389                }
    390          
    391                cfg->flag |= UART_CFG_TXF;
   \   0001BB   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   0001BE   D2E0         SETB    0xE0 /* A   */.0
   \   0001C0   F0           MOVX    @DPTR,A
    392                DMA_TX( cfg );
   \   0001C1   EE           MOV     A,R6
   \   0001C2   2408         ADD     A,#0x8
   \   0001C4   F8           MOV     R0,A
   \   0001C5   EF           MOV     A,R7
   \   0001C6   3400         ADDC    A,#0x0
   \   0001C8   F9           MOV     R1,A
   \   0001C9   EE           MOV     A,R6
   \   0001CA   240B         ADD     A,#0xb
   \   0001CC   FA           MOV     R2,A
   \   0001CD   12....       LCALL   ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   0001D0   8882         MOV     DPL,R0
   \   0001D2   8983         MOV     DPH,R1
   \   0001D4   E0           MOVX    A,@DPTR
   \   0001D5   2C           ADD     A,R4
   \   0001D6   A3           INC     DPTR
   \   0001D7   E0           MOVX    A,@DPTR
   \   0001D8   3400         ADDC    A,#0x0
   \   0001DA   90....       MOV     DPTR,#(dmaCh1234 + 16)
   \   0001DD   F0           MOVX    @DPTR,A
   \   0001DE   8A82         MOV     DPL,R2
   \   0001E0   8B83         MOV     DPH,R3
   \   0001E2   E0           MOVX    A,@DPTR
   \   0001E3   FA           MOV     R2,A
   \   0001E4   8882         MOV     DPL,R0
   \   0001E6   8983         MOV     DPH,R1
   \   0001E8   E0           MOVX    A,@DPTR
   \   0001E9   2A           ADD     A,R2
   \   0001EA   90....       MOV     DPTR,#(dmaCh1234 + 17)
   \   0001ED   F0           MOVX    @DPTR,A
   \   0001EE   EE           MOV     A,R6
   \   0001EF   240D         ADD     A,#0xd
   \   0001F1   12....       LCALL   ??Subroutine7_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_26:
   \   0001F4   90....       MOV     DPTR,#(dmaCh1234 + 21)
   \   0001F7   F0           MOVX    @DPTR,A
   \   0001F8   90....       MOV     DPTR,#(dmaCh1234 + 20)
   \   0001FB   E0           MOVX    A,@DPTR
   \   0001FC   54E0         ANL     A,#0xe0
   \   0001FE   F0           MOVX    @DPTR,A
   \   0001FF   53D1F7       ANL     0xd1,#0xf7
   \   000202   75D608       MOV     0xd6,#0x8
   \   000205   75D708       MOV     0xd7,#0x8
    393              }
    394            }
    395          }
   \                     ??pollDMA_15:
   \   000208   7401         MOV     A,#0x1
   \   00020A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00020D   7F02         MOV     R7,#0x2
   \   00020F   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000212                REQUIRE _A_P0
   \   000212                REQUIRE _A_P1
   \   000212                REQUIRE U0DBUF
   \   000212                REQUIRE U0BAUD
   \   000212                REQUIRE DMAIRQ
   \   000212                REQUIRE DMAARM
   \   000212                REQUIRE DMAREQ

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   EF           MOV     A,R7
   \   000001   3400         ADDC    A,#0x0
   \   000003   FB           MOV     R3,A
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   E0           MOVX    A,@DPTR
   \   000009   FC           MOV     R4,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   EE           MOV     A,R6
   \   000001   240D         ADD     A,#0xd
   \                     ??Subroutine2_0:
   \   000003   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   000006   FA           MOV     R2,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   000003   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A                REQUIRE ?Subroutine22
   \   00000A                ; // Fall through to label ?Subroutine22

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   240B         ADD     A,#0xb
   \                     ??Subroutine21_0:
   \   000002   F582         MOV     DPL,A
   \   000004   EF           MOV     A,R7
   \   000005   3400         ADDC    A,#0x0
   \   000007   F583         MOV     DPH,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   E4           CLR     A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   00000B   A3           INC     DPTR
   \   00000C   F0           MOVX    @DPTR,A
   \   00000D   EE           MOV     A,R6
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   12....       LCALL   ??osal_memset?relay
   \   000003   E5C1         MOV     A,0xc1
   \   000005   85..82       MOV     DPL,?XSP + 0
   \   000008   85..83       MOV     DPH,?XSP + 1
   \   00000B   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   90....       MOV     DPTR,#(dmaCh1234 + 26)
   \   000012   F0           MOVX    @DPTR,A
   \   000013   8E82         MOV     DPL,R6
   \   000015   8F83         MOV     DPH,R7
   \   000017   E0           MOVX    A,@DPTR
   \   000018   90....       MOV     DPTR,#(dmaCh1234 + 27)
   \   00001B   F0           MOVX    @DPTR,A
   \   00001C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   C3           CLR     C
   \   000002   33           RLC     A
   \   000003   FC           MOV     R4,A
   \   000004   E4           CLR     A
   \   000005   33           RLC     A
   \   000006   FD           MOV     R5,A
   \   000007   E5C2         MOV     A,0xc2
   \   000009   F4           CPL     A
   \   00000A   F9           MOV     R1,A
   \   00000B   8E82         MOV     DPL,R6
   \   00000D   8F83         MOV     DPH,R7
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   FA           MOV     R2,A
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   90....       MOV     DPTR,#(dmaCh1234 + 29)
   \   000004   F0           MOVX    @DPTR,A
   \   000005   90....       MOV     DPTR,#(dmaCh1234 + 28)
   \   000008   E0           MOVX    A,@DPTR
   \   000009   54E0         ANL     A,#0xe0
   \   00000B   F0           MOVX    @DPTR,A
   \   00000C   53D1EF       ANL     0xd1,#0xef
   \   00000F   75D610       MOV     0xd6,#0x10
   \   000012   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   A3           INC     DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   6A           XRL     A,R2
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   8E82         MOV     DPL,R6
   \   000004   8F83         MOV     DPH,R7
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   EE           MOV     A,R6
   \   000001   240F         ADD     A,#0xf
   \   000003   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   000006   A2E7         MOV     C,0xE0 /* A   */.7
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   E0           MOVX    A,@DPTR
   \   000009   F8           MOV     R0,A
   \   00000A   74D0         MOV     A,#-0x30
   \   00000C   28           ADD     A,R0
   \   00000D   F8           MOV     R0,A
   \   00000E   74FF         MOV     A,#-0x1
   \   000010   3400         ADDC    A,#0x0
   \   000012   F9           MOV     R1,A
   \   000013   C3           CLR     C
   \   000014   EA           MOV     A,R2
   \   000015   98           SUBB    A,R0
   \   000016   E4           CLR     A
   \   000017   99           SUBB    A,R1
   \   000018   A2D2         MOV     C,0xD0 /* PSW */.2
   \   00001A   65D0         XRL     A,PSW
   \   00001C   33           RLC     A
   \   00001D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   EE           MOV     A,R6
   \   000001   240F         ADD     A,#0xf
   \                     ??Subroutine7_0:
   \   000003   F582         MOV     DPL,A
   \   000005   EF           MOV     A,R7
   \                     ??Subroutine7_1:
   \   000006   12....       LCALL   ??Subroutine20_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   F582         MOV     DPL,A
   \   000002   EF           MOV     A,R7
   \                     ??Subroutine20_0:
   \   000003   3400         ADDC    A,#0x0
   \   000005   F583         MOV     DPH,A
   \   000007   E0           MOVX    A,@DPTR
   \   000008   22           RET
    396          #endif
    397          
    398          #if HAL_UART_ISR
    399          /******************************************************************************
    400           * @fn      pollISR
    401           *
    402           * @brief   Poll a USART module implemented by ISR.
    403           *
    404           * @param   cfg - USART configuration structure.
    405           *
    406           * @return  none
    407           *****************************************************************************/
    408          static void pollISR( uartCfg_t *cfg )
    409          {
    410            uint8 cnt = UART_RX_AVAIL( cfg );
    411          
    412            if ( !(cfg->flag & UART_CFG_RXF) )
    413            {
    414              // If anything received, reset the Rx idle timer.
    415              if ( cfg->rxCnt != cnt )
    416              {
    417                cfg->rxTick = HAL_UART_RX_IDLE;
    418                cfg->rxCnt = cnt;
    419              }
    420          
    421              /* It is necessary to stop Rx flow in advance of a full Rx buffer because
    422               * bytes can keep coming while sending H/W fifo flushes.
    423               */
    424              if ( cfg->rxCnt >= (cfg->rxMax - SAFE_RX_MIN) )
    425              {
    426                RX_STOP_FLOW( cfg );
    427              }
    428            }
    429          }
    430          #endif
    431          
    432          /******************************************************************************
    433           * @fn      HalUARTInit
    434           *
    435           * @brief   Initialize the UART
    436           *
    437           * @param   none
    438           *
    439           * @return  none
    440           *****************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    441          void HalUARTInit( void )
   \                     HalUARTInit:
    442          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    443          #if HAL_UART_DMA
    444            halDMADesc_t *ch;
    445          #endif
    446          
    447            // Set P2 priority - USART0 over USART1 if both are defined.
    448            P2DIR &= ~P2DIR_PRIPO;
   \   000004   53FF3F       ANL     0xff,#0x3f
   \   000007   E5FF         MOV     A,0xff
    449            P2DIR |= HAL_UART_PRIPO;
   \   000009   85FFFF       MOV     0xff,0xff
    450          
    451          #if HAL_UART_0_ENABLE
    452            // Set UART0 I/O location to P0.
    453            PERCFG &= ~HAL_UART_0_PERCFG_BIT;
   \   00000C   53F1FE       ANL     0xf1,#0xfe
    454          
    455            /* Enable Tx and Rx on P0 */
    456            P0SEL |= HAL_UART_0_P0_RX_TX;
   \   00000F   43F30C       ORL     0xf3,#0xc
   \   000012   E5F3         MOV     A,0xf3
    457          
    458            /* Make sure ADC doesnt use this */
    459            ADCCFG &= ~HAL_UART_0_P0_RX_TX;
   \   000014   53F2F3       ANL     0xf2,#0xf3
   \   000017   E5F2         MOV     A,0xf2
    460          
    461            /* Mode is UART Mode */
    462            U0CSR = CSR_MODE;
   \   000019   758680       MOV     0x86,#-0x80
    463          
    464            /* Flush it */
    465            U0UCR = UCR_FLUSH;
   \   00001C   75C480       MOV     0xc4,#-0x80
    466          #endif
    467          
    468          #if HAL_UART_1_ENABLE
    469            // Set UART1 I/O location to P1.
    470            PERCFG |= HAL_UART_1_PERCFG_BIT;
    471          
    472            /* Enable Tx and Rx on P1 */
    473            P1SEL  |= HAL_UART_1_P1_RX_TX;
    474          
    475            /* Make sure ADC doesnt use this */
    476            ADCCFG &= ~HAL_UART_1_P1_RX_TX;
    477          
    478            /* Mode is UART Mode */
    479            U1CSR = CSR_MODE;
    480          
    481            /* Flush it */
    482            U1UCR = UCR_FLUSH;
    483          #endif
    484          
    485          #if HAL_UART_DMA
    486            // Setup Tx by DMA.
    487            ch = HAL_DMA_GET_DESC1234( HAL_DMA_CH_TX );
    488          
    489            // The start address of the destination.
    490            HAL_DMA_SET_DEST( ch, DMA_UDBUF );
   \   00001F   74DF         MOV     A,#-0x21
   \   000021   90....       MOV     DPTR,#(dmaCh1234 + 18)
   \   000024   F0           MOVX    @DPTR,A
   \   000025   74C1         MOV     A,#-0x3f
   \   000027   90....       MOV     DPTR,#(dmaCh1234 + 19)
   \   00002A   F0           MOVX    @DPTR,A
    491          
    492            // Using the length field to determine how many bytes to transfer.
    493            HAL_DMA_SET_VLEN( ch, HAL_DMA_VLEN_USE_LEN );
   \   00002B   90....       MOV     DPTR,#(dmaCh1234 + 20)
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   541F         ANL     A,#0x1f
   \   000031   F0           MOVX    @DPTR,A
    494          
    495            // One byte is transferred each time.
    496            HAL_DMA_SET_WORD_SIZE( ch, HAL_DMA_WORDSIZE_BYTE );
    497          
    498            // The bytes are transferred 1-by-1 on Tx Complete trigger.
    499            HAL_DMA_SET_TRIG_MODE( ch, HAL_DMA_TMODE_SINGLE );
    500            HAL_DMA_SET_TRIG_SRC( ch, DMATRIG_TX );
   \   000032   740F         MOV     A,#0xf
   \   000034   90....       MOV     DPTR,#(dmaCh1234 + 22)
   \   000037   F0           MOVX    @DPTR,A
    501          
    502            // The source address is decremented by 1 byte after each transfer.
    503            HAL_DMA_SET_SRC_INC( ch, HAL_DMA_SRCINC_1 );
    504          
    505            // The destination address is constant - the Tx Data Buffer.
    506            HAL_DMA_SET_DST_INC( ch, HAL_DMA_DSTINC_0 );
    507          
    508            // The DMA is to be polled and shall not issue an IRQ upon completion.
    509            HAL_DMA_SET_IRQ( ch, HAL_DMA_IRQMASK_DISABLE );
    510          
    511            // Xfer all 8 bits of a byte xfer.
    512            HAL_DMA_SET_M8( ch, HAL_DMA_M8_USE_8_BITS );
    513          
    514            // DMA Tx has shared priority for memory access - every other one.
    515            HAL_DMA_SET_PRIORITY( ch, HAL_DMA_PRI_HIGH );
   \   000038   7442         MOV     A,#0x42
   \   00003A   90....       MOV     DPTR,#(dmaCh1234 + 23)
   \   00003D   F0           MOVX    @DPTR,A
    516          
    517            // Setup Rx by DMA.
    518            ch = HAL_DMA_GET_DESC1234( HAL_DMA_CH_RX );
    519          
    520            // The start address of the source.
    521            HAL_DMA_SET_SOURCE( ch, DMA_UDBUF );
   \   00003E   74DF         MOV     A,#-0x21
   \   000040   90....       MOV     DPTR,#(dmaCh1234 + 24)
   \   000043   F0           MOVX    @DPTR,A
   \   000044   74C1         MOV     A,#-0x3f
   \   000046   90....       MOV     DPTR,#(dmaCh1234 + 25)
   \   000049   F0           MOVX    @DPTR,A
    522          
    523            // Using the length field to determine how many bytes to transfer.
    524            HAL_DMA_SET_VLEN( ch, HAL_DMA_VLEN_USE_LEN );
   \   00004A   90....       MOV     DPTR,#(dmaCh1234 + 28)
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   541F         ANL     A,#0x1f
   \   000050   F0           MOVX    @DPTR,A
    525          
    526            /* The trick is to cfg DMA to xfer 2 bytes for every 1 byte of Rx.
    527             * The byte after the Rx Data Buffer is the Baud Cfg Register,
    528             * which always has a known value. So init Rx buffer to inverse of that
    529             * known value. DMA word xfer will flip the bytes, so every valid Rx byte
    530             * in the Rx buffer will be preceded by a DMA_PAD char equal to the
    531             * Baud Cfg Register value.
    532             */
    533            HAL_DMA_SET_WORD_SIZE( ch, HAL_DMA_WORDSIZE_WORD );
    534          
    535            // The bytes are transferred 1-by-1 on Rx Complete trigger.
    536            HAL_DMA_SET_TRIG_MODE( ch, HAL_DMA_TMODE_SINGLE );
    537            HAL_DMA_SET_TRIG_SRC( ch, DMATRIG_RX );
   \   000051   748E         MOV     A,#-0x72
   \   000053   90....       MOV     DPTR,#(dmaCh1234 + 30)
   \   000056   F0           MOVX    @DPTR,A
    538          
    539            // The source address is constant - the Rx Data Buffer.
    540            HAL_DMA_SET_SRC_INC( ch, HAL_DMA_SRCINC_0 );
    541          
    542            // The destination address is incremented by 1 word after each transfer.
    543            HAL_DMA_SET_DST_INC( ch, HAL_DMA_DSTINC_1 );
    544          
    545            // The DMA is to be polled and shall not issue an IRQ upon completion.
    546            HAL_DMA_SET_IRQ( ch, HAL_DMA_IRQMASK_DISABLE );
    547          
    548            // Xfer all 8 bits of a byte xfer.
    549            HAL_DMA_SET_M8( ch, HAL_DMA_M8_USE_8_BITS );
    550          
    551            // DMA has highest priority for memory access.
    552            HAL_DMA_SET_PRIORITY( ch, HAL_DMA_PRI_HIGH );
   \   000057   7412         MOV     A,#0x12
   \   000059   90....       MOV     DPTR,#(dmaCh1234 + 31)
   \   00005C   F0           MOVX    @DPTR,A
    553          #endif
    554          }
   \   00005D                REQUIRE ?Subroutine23
   \   00005D                REQUIRE U0CSR
   \   00005D                REQUIRE U0UCR
   \   00005D                REQUIRE PERCFG
   \   00005D                REQUIRE ADCCFG
   \   00005D                REQUIRE P0SEL
   \   00005D                REQUIRE P2DIR
   \   00005D                ; // Fall through to label ?Subroutine23

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    555          
    556          /******************************************************************************
    557           * @fn      HalUARTOpen
    558           *
    559           * @brief   Open a port according tp the configuration specified by parameter.
    560           *
    561           * @param   port   - UART port
    562           *          config - contains configuration information
    563           *
    564           * @return  Status of the function call
    565           *****************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    566          uint8 HalUARTOpen( uint8 port, halUARTCfg_t *config )
   \                     HalUARTOpen:
    567          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V0 + 2,R1
   \   00000C   8A..         MOV     ?V0 + 0,R2
   \   00000E   8B..         MOV     ?V0 + 1,R3
    568            uartCfg_t **cfgPP = NULL;
   \   000010   7E00         MOV     R6,#0x0
   \   000012   7F00         MOV     R7,#0x0
    569            uartCfg_t *cfg;
    570          
    571          #if HAL_UART_0_ENABLE
    572            if ( port == HAL_UART_PORT_0 )
   \   000014   E9           MOV     A,R1
   \   000015   7004         JNZ     ??HalUARTOpen_0
    573            {
    574              cfgPP = &cfg0;
   \   000017   7E..         MOV     R6,#(cfg0 & 0xff)
   \   000019   7F..         MOV     R7,#((cfg0 >> 8) & 0xff)
    575            }
    576          #endif
    577          
    578          #if HAL_UART_1_ENABLE
    579            if ( port == HAL_UART_PORT_1 )
    580            {
    581              cfgPP = &cfg1;
    582            }
    583          #endif
    584          
    585            HAL_UART_ASSERT( cfgPP );
    586          
    587          #if HAL_UART_CLOSE
    588            // Protect against user re-opening port before closing it.
    589            HalUARTClose( port );
    590          #else
    591            HAL_UART_ASSERT( *cfgPP == NULL );
    592          #endif
    593          
    594            HAL_UART_ASSERT( (config->baudRate == HAL_UART_BR_38400) ||
    595                             (config->baudRate == HAL_UART_BR_115200) );
    596          
    597            /* Whereas runtime heap alloc can be expected to fail - one-shot system
    598             * initialization must succeed, so no check for alloc fail.
    599             */
    600            *cfgPP = (uartCfg_t *)osal_mem_alloc( sizeof( uartCfg_t ) );
   \                     ??HalUARTOpen_0:
   \   00001B                ; Setup parameters for call to function osal_mem_alloc
   \   00001B   7A12         MOV     R2,#0x12
   \   00001D   7B00         MOV     R3,#0x0
   \   00001F   12....       LCALL   ?Subroutine17 & 0xFFFF
    601            cfg = *cfgPP;
   \                     ??CrossCallReturnLabel_51:
   \   000022   8E82         MOV     DPL,R6
   \   000024   8F83         MOV     DPH,R7
   \   000026   E0           MOVX    A,@DPTR
   \   000027   FE           MOV     R6,A
   \   000028   A3           INC     DPTR
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   FF           MOV     R7,A
    602            HAL_UART_ASSERT( cfg );
    603          
    604            cfg->rxMax = config->rx.maxBufSize;
   \   00002B   E5..         MOV     A,?V0 + 0
   \   00002D   240A         ADD     A,#0xa
   \   00002F   F5..         MOV     ?V0 + 4,A
   \   000031   E5..         MOV     A,?V0 + 1
   \   000033   3400         ADDC    A,#0x0
   \   000035   F5..         MOV     ?V0 + 5,A
   \   000037   85..82       MOV     DPL,?V0 + 4
   \   00003A   F583         MOV     DPH,A
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   8E82         MOV     DPL,R6
   \   00003F   8F83         MOV     DPH,R7
   \   000041   A3           INC     DPTR
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   F0           MOVX    @DPTR,A
    605          
    606          #if !HAL_UART_BIG_TX_BUF
    607            HAL_UART_ASSERT( (config->tx.maxBufSize < 256) );
    608          #endif
    609            cfg->txMax = config->tx.maxBufSize;
   \   000046   EE           MOV     A,R6
   \   000047   240C         ADD     A,#0xc
   \   000049   F8           MOV     R0,A
   \   00004A   EF           MOV     A,R7
   \   00004B   3400         ADDC    A,#0x0
   \   00004D   F9           MOV     R1,A
   \   00004E   E5..         MOV     A,?V0 + 0
   \   000050   2412         ADD     A,#0x12
   \   000052   F582         MOV     DPL,A
   \   000054   E5..         MOV     A,?V0 + 1
   \   000056   12....       LCALL   ??Subroutine7_1 & 0xFFFF
   \                     ??CrossCallReturnLabel_27:
   \   000059   8882         MOV     DPL,R0
   \   00005B   8983         MOV     DPH,R1
   \   00005D   F0           MOVX    @DPTR,A
    610            cfg->txBuf = osal_mem_alloc( cfg->txMax+1 );
   \   00005E                ; Setup parameters for call to function osal_mem_alloc
   \   00005E   F8           MOV     R0,A
   \   00005F   7401         MOV     A,#0x1
   \   000061   28           ADD     A,R0
   \   000062   FA           MOV     R2,A
   \   000063   E4           CLR     A
   \   000064   3400         ADDC    A,#0x0
   \   000066   FB           MOV     R3,A
   \   000067   12....       LCALL   ??osal_mem_alloc?relay
   \   00006A   8E82         MOV     DPL,R6
   \   00006C   8F83         MOV     DPH,R7
   \   00006E   A3           INC     DPTR
   \   00006F   A3           INC     DPTR
   \   000070   A3           INC     DPTR
   \   000071   A3           INC     DPTR
   \   000072   A3           INC     DPTR
   \   000073   A3           INC     DPTR
   \   000074   A3           INC     DPTR
   \   000075   A3           INC     DPTR
   \   000076   EA           MOV     A,R2
   \   000077   F0           MOVX    @DPTR,A
   \   000078   A3           INC     DPTR
   \   000079   EB           MOV     A,R3
   \   00007A   F0           MOVX    @DPTR,A
    611          
    612            cfg->rxHead = cfg->rxTail = 0;
   \   00007B   12....       LCALL   ?Subroutine16 & 0xFFFF
    613            cfg->txHead = cfg->txTail = 0;
   \                     ??CrossCallReturnLabel_50:
   \   00007E   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   000081   E4           CLR     A
   \   000082   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   000085   A3           INC     DPTR
   \   000086   A3           INC     DPTR
   \   000087   A3           INC     DPTR
   \   000088   A3           INC     DPTR
   \   000089   F0           MOVX    @DPTR,A
    614            cfg->rxHigh = config->rx.maxBufSize - config->flowControlThreshold;
   \   00008A   85..82       MOV     DPL,?V0 + 0
   \   00008D   85..83       MOV     DPH,?V0 + 1
   \   000090   A3           INC     DPTR
   \   000091   A3           INC     DPTR
   \   000092   A3           INC     DPTR
   \   000093   E0           MOVX    A,@DPTR
   \   000094   F8           MOV     R0,A
   \   000095   85..82       MOV     DPL,?V0 + 4
   \   000098   85..83       MOV     DPH,?V0 + 5
   \   00009B   E0           MOVX    A,@DPTR
   \   00009C   C3           CLR     C
   \   00009D   98           SUBB    A,R0
   \   00009E   8E82         MOV     DPL,R6
   \   0000A0   8F83         MOV     DPH,R7
   \   0000A2   A3           INC     DPTR
   \   0000A3   A3           INC     DPTR
   \   0000A4   A3           INC     DPTR
   \   0000A5   A3           INC     DPTR
   \   0000A6   A3           INC     DPTR
   \   0000A7   A3           INC     DPTR
   \   0000A8   A3           INC     DPTR
   \   0000A9   F0           MOVX    @DPTR,A
    615            cfg->rxCB = config->callBackFunc;
   \   0000AA   E5..         MOV     A,?V0 + 0
   \   0000AC   241B         ADD     A,#0x1b
   \   0000AE   F582         MOV     DPL,A
   \   0000B0   E5..         MOV     A,?V0 + 1
   \   0000B2   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   0000B5   F9           MOV     R1,A
   \   0000B6   EE           MOV     A,R6
   \   0000B7   2410         ADD     A,#0x10
   \   0000B9   12....       LCALL   ??Subroutine21_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_67:
   \   0000BC   E8           MOV     A,R0
   \   0000BD   F0           MOVX    @DPTR,A
   \   0000BE   A3           INC     DPTR
   \   0000BF   E9           MOV     A,R1
   \   0000C0   F0           MOVX    @DPTR,A
    616          
    617          #if HAL_UART_0_ENABLE
    618            if ( port == HAL_UART_PORT_0 )
   \   0000C1   E5..         MOV     A,?V0 + 2
   \   0000C3   7061         JNZ     ??HalUARTOpen_1
    619            {
    620              // Only supporting 38400 or 115200 for code size - other is possible.
    621              U0BAUD = 59;/*modified by xiaoyang,boardrate:9600*/
   \   0000C5   75C23B       MOV     0xc2,#0x3b
    622              U0GCR = 8;
   \   0000C8   75C508       MOV     0xc5,#0x8
    623              //U0BAUD = (config->baudRate == HAL_UART_BR_38400) ? 59 : 216;
    624              //U0GCR = (config->baudRate == HAL_UART_BR_38400) ? 10 : 11;
    625          
    626              U0CSR |= CSR_RE;
   \   0000CB   438640       ORL     0x86,#0x40
    627          
    628          #if HAL_UART_DMA == 1
    629              cfg->flag = UART_CFG_DMA;
   \   0000CE   EE           MOV     A,R6
   \   0000CF   240F         ADD     A,#0xf
   \   0000D1   12....       LCALL   ??Subroutine21_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   0000D4   7440         MOV     A,#0x40
   \   0000D6   F0           MOVX    @DPTR,A
    630              HAL_UART_ASSERT( (config->rx.maxBufSize <= 128) );
    631              HAL_UART_ASSERT( (config->rx.maxBufSize > SAFE_RX_MIN) );
    632              cfg->rxBuf = osal_mem_alloc( cfg->rxMax*2 );
   \   0000D7   EE           MOV     A,R6
   \   0000D8   2404         ADD     A,#0x4
   \   0000DA   F5..         MOV     ?V0 + 2,A
   \   0000DC   EF           MOV     A,R7
   \   0000DD   3400         ADDC    A,#0x0
   \   0000DF   F5..         MOV     ?V0 + 3,A
   \   0000E1                ; Setup parameters for call to function osal_mem_alloc
   \   0000E1   85..82       MOV     DPL,?V0 + 2
   \   0000E4   F583         MOV     DPH,A
   \   0000E6   E0           MOVX    A,@DPTR
   \   0000E7   C3           CLR     C
   \   0000E8   33           RLC     A
   \   0000E9   FA           MOV     R2,A
   \   0000EA   E4           CLR     A
   \   0000EB   33           RLC     A
   \   0000EC   FB           MOV     R3,A
   \   0000ED   12....       LCALL   ?Subroutine17 & 0xFFFF
    633              osal_memset( cfg->rxBuf, ~DMA_PAD, cfg->rxMax*2 );
   \                     ??CrossCallReturnLabel_52:
   \   0000F0                ; Setup parameters for call to function osal_memset
   \   0000F0   85..82       MOV     DPL,?V0 + 2
   \   0000F3   85..83       MOV     DPH,?V0 + 3
   \   0000F6   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   0000F9   12....       LCALL   ?Subroutine10 & 0xFFFF
    634              DMA_RX( cfg );
   \                     ??CrossCallReturnLabel_40:
   \   0000FC   85..82       MOV     DPL,?V0 + 2
   \   0000FF   85..83       MOV     DPH,?V0 + 3
   \   000102   12....       LCALL   ?Subroutine8 & 0xFFFF
    635          #else
    636              cfg->flag = 0;
    637              HAL_UART_ASSERT( (config->rx.maxBufSize < 256) );
    638              cfg->rxBuf = osal_mem_alloc( cfg->rxMax+1 );
    639              URX0IE = 1;
    640              IEN2 |= UTX0IE;
    641          #endif
    642          
    643              // 8 bits/char; no parity; 1 stop bit; stop bit hi.
    644              if ( config->flowControl )
   \                     ??CrossCallReturnLabel_36:
   \   000105   85..82       MOV     DPL,?V0 + 0
   \   000108   85..83       MOV     DPH,?V0 + 1
   \   00010B   A3           INC     DPTR
   \   00010C   A3           INC     DPTR
   \   00010D   E0           MOVX    A,@DPTR
   \   00010E   6013         JZ      ??HalUARTOpen_2
    645              {
    646                cfg->flag |= UART_CFG_FLW;
   \   000110   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_28:
   \   000113   D2E5         SETB    0xE0 /* A   */.5
   \   000115   F0           MOVX    @DPTR,A
    647                U0UCR = UCR_FLOW | UCR_STOP;
   \   000116   75C442       MOV     0xc4,#0x42
    648                // Must rely on H/W for RTS (i.e. Tx stops when receiver negates CTS.)
    649                P0SEL |= HAL_UART_0_P0_RTS;
   \   000119   43F310       ORL     0xf3,#0x10
    650                // Cannot use H/W for CTS as DMA does not clear the Rx bytes properly.
    651                P0DIR |= HAL_UART_0_P0_CTS;
   \   00011C   43FD20       ORL     0xfd,#0x20
    652                RX0_FLOW_ON;
   \   00011F   C285         CLR     0x80.5
   \   000121   8003         SJMP    ??HalUARTOpen_1
    653              }
    654              else
    655              {
    656                U0UCR = UCR_STOP;
   \                     ??HalUARTOpen_2:
   \   000123   75C402       MOV     0xc4,#0x2
    657              }
    658              }
    659          #endif
    660          
    661          #if HAL_UART_1_ENABLE
    662            if ( port == HAL_UART_PORT_1 )
    663            {
    664              // Only supporting 38400 or 115200 for code size - other is possible.
    665              U1BAUD = (config->baudRate == HAL_UART_BR_38400) ? 59 : 216;
    666              U1GCR = (config->baudRate == HAL_UART_BR_38400) ? 10 : 11;
    667          
    668              U1CSR |= CSR_RE;
    669          
    670          #if HAL_UART_DMA == 2
    671              cfg->flag = (UART_CFG_U1F | UART_CFG_DMA);
    672              HAL_UART_ASSERT( (config->rx.maxBufSize <= 128) );
    673              HAL_UART_ASSERT( (config->rx.maxBufSize > SAFE_RX_MIN) );
    674              cfg->rxBuf = osal_mem_alloc( cfg->rxMax*2 );
    675              osal_memset( cfg->rxBuf, ~DMA_PAD, cfg->rxMax*2 );
    676              DMA_RX( cfg );
    677          #else
    678              cfg->flag = UART_CFG_U1F;
    679              HAL_UART_ASSERT( (config->rx.maxBufSize < 256) );
    680              cfg->rxBuf = osal_mem_alloc( cfg->rxMax+1 );
    681              URX1IE = 1;
    682              IEN2 |= UTX1IE;
    683          #endif
    684          
    685              // 8 bits/char; no parity; 1 stop bit; stop bit hi.
    686              if ( config->flowControl )
    687              {
    688                cfg->flag |= UART_CFG_FLW;
    689                U1UCR = UCR_FLOW | UCR_STOP;
    690                // Must rely on H/W for RTS (i.e. Tx stops when receiver negates CTS.)
    691                P1SEL |= HAL_UART_1_P1_RTS;
    692                // Cannot use H/W for CTS as DMA does not clear the Rx bytes properly.
    693                P1DIR |= HAL_UART_1_P1_CTS;
    694                RX1_FLOW_ON;
    695              }
    696              else
    697              {
    698                U1UCR = UCR_STOP;
    699              }
    700            }
    701          #endif
    702          
    703            return HAL_UART_SUCCESS;
   \                     ??HalUARTOpen_1:
   \   000126   7900         MOV     R1,#0x0
   \   000128   7401         MOV     A,#0x1
   \   00012A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00012D   7F06         MOV     R7,#0x6
   \   00012F   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000132                REQUIRE _A_P0
   \   000132                REQUIRE U0CSR
   \   000132                REQUIRE U0DBUF
   \   000132                REQUIRE U0BAUD
   \   000132                REQUIRE U0UCR
   \   000132                REQUIRE U0GCR
   \   000132                REQUIRE DMAIRQ
   \   000132                REQUIRE DMAARM
   \   000132                REQUIRE P0SEL
   \   000132                REQUIRE P0DIR
    704          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   12....       LCALL   ??osal_mem_alloc?relay
   \   000003   8E82         MOV     DPL,R6
   \   000005   8F83         MOV     DPH,R7
   \   000007   EA           MOV     A,R2
   \   000008   F0           MOVX    @DPTR,A
   \   000009   A3           INC     DPTR
   \   00000A   EB           MOV     A,R3
   \   00000B   F0           MOVX    @DPTR,A
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   12....       LCALL   ??Subroutine20_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   000003   F8           MOV     R0,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   22           RET
    705          
    706          /******************************************************************************
    707           * @fn      HalUARTClose
    708           *
    709           * @brief   Close the UART
    710           *
    711           * @param   port - UART port
    712           *
    713           * @return  none
    714           *****************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    715          void HalUARTClose( uint8 port )
   \                     HalUARTClose:
    716          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    717          #if HAL_UART_CLOSE
    718            uartCfg_t *cfg;
    719          
    720          #if HAL_UART_0_ENABLE
    721            if ( port == HAL_UART_PORT_0 )
    722            {
    723              U0CSR &= ~CSR_RE;
    724          #if HAL_UART_DMA == 1
    725              HAL_DMA_ABORT_CH( HAL_DMA_CH_RX );
    726              HAL_DMA_ABORT_CH( HAL_DMA_CH_TX );
    727          #else
    728              URX0IE = 0;
    729          #endif
    730              cfg = cfg0;
    731              cfg0 = NULL;
    732            }
    733          #endif
    734          #if HAL_UART_1_ENABLE
    735            if ( port == HAL_UART_PORT_1 )
    736            {
    737              U1CSR &= ~CSR_RE;
    738          #if HAL_UART_DMA == 2
    739              HAL_DMA_ABORT_CH( HAL_DMA_CH_RX );
    740              HAL_DMA_ABORT_CH( HAL_DMA_CH_TX );
    741          #else
    742              URX1IE = 0;
    743          #endif
    744              cfg = cfg1;
    745              cfg1 = NULL;
    746            }
    747          #endif
    748          
    749            if ( cfg )
    750            {
    751              if ( cfg->rxBuf )
    752              {
    753                osal_mem_free( cfg->rxBuf );
    754              }
    755              if ( cfg->txBuf )
    756              {
    757                osal_mem_free( cfg->txBuf );
    758              }
    759              osal_mem_free( cfg );
    760            }
    761          #endif
    762          }
   \   000000   02....       LJMP    ?BRET
    763          
    764          /******************************************************************************
    765           * @fn      HalUARTPoll
    766           *
    767           * @brief   Poll the UART.
    768           *
    769           * @param   none
    770           *
    771           * @return  none
    772           *****************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    773          void HalUARTPoll( void )
   \                     HalUARTPoll:
    774          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    775          #if ( HAL_UART_0_ENABLE | HAL_UART_1_ENABLE )
    776            static uint8 tickShdw;
    777            uartCfg_t *cfg;
    778            uint8 tick;
    779          
    780          #if HAL_UART_0_ENABLE
    781            if ( cfg0 )
   \   000005   90....       MOV     DPTR,#cfg0
   \   000008   E0           MOVX    A,@DPTR
   \   000009   7002         JNZ     ??HalUARTPoll_0
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \                     ??HalUARTPoll_0:
   \   00000D   6008         JZ      ??HalUARTPoll_1
    782            {
    783              cfg = cfg0;
   \   00000F   90....       MOV     DPTR,#cfg0
   \   000012   E0           MOVX    A,@DPTR
   \   000013   FE           MOV     R6,A
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   FF           MOV     R7,A
    784            }
    785          #endif
    786          #if HAL_UART_1_ENABLE
    787            if ( cfg1 )
    788            {
    789              cfg = cfg1;
    790            }
    791          #endif
    792          
    793            // Use the LSB of the sleep timer (ST0 must be read first anyway).
    794            tick = ST0 - tickShdw;
   \                     ??HalUARTPoll_1:
   \   000017   90....       MOV     DPTR,#??tickShdw
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   FA           MOV     R2,A
   \   00001C   E595         MOV     A,0x95
   \   00001E   C3           CLR     C
   \   00001F   9A           SUBB    A,R2
   \   000020   FA           MOV     R2,A
    795            tickShdw = ST0;
   \   000021   E595         MOV     A,0x95
   \   000023   F0           MOVX    @DPTR,A
    796          
    797            do
    798            {
    799              if ( cfg->txTick > tick )
   \   000024   EE           MOV     A,R6
   \   000025   240E         ADD     A,#0xe
   \   000027   12....       LCALL   ??Subroutine7_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_29:
   \   00002A   FB           MOV     R3,A
   \   00002B   EA           MOV     A,R2
   \   00002C   C3           CLR     C
   \   00002D   9B           SUBB    A,R3
   \   00002E   5005         JNC     ??HalUARTPoll_2
    800              {
    801                cfg->txTick -= tick;
   \   000030   E0           MOVX    A,@DPTR
   \   000031   C3           CLR     C
   \   000032   9A           SUBB    A,R2
   \   000033   8001         SJMP    ??HalUARTPoll_3
    802              }
    803              else
    804              {
    805                cfg->txTick = 0;
   \                     ??HalUARTPoll_2:
   \   000035   E4           CLR     A
   \                     ??HalUARTPoll_3:
   \   000036   12....       LCALL   ?Subroutine15 & 0xFFFF
    806              }
    807          
    808              if ( cfg->rxTick > tick )
   \                     ??CrossCallReturnLabel_47:
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   FB           MOV     R3,A
   \   00003B   EA           MOV     A,R2
   \   00003C   C3           CLR     C
   \   00003D   9B           SUBB    A,R3
   \   00003E   500F         JNC     ??HalUARTPoll_4
    809              {
    810                cfg->rxTick -= tick;
   \   000040   8E82         MOV     DPL,R6
   \   000042   8F83         MOV     DPH,R7
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   C3           CLR     C
   \   00004C   9A           SUBB    A,R2
   \   00004D   800B         SJMP    ??HalUARTPoll_5
    811              }
    812              else
    813              {
    814                cfg->rxTick = 0;
   \                     ??HalUARTPoll_4:
   \   00004F   E4           CLR     A
   \   000050   8E82         MOV     DPL,R6
   \   000052   8F83         MOV     DPH,R7
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   A3           INC     DPTR
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \                     ??HalUARTPoll_5:
   \   00005A   F0           MOVX    @DPTR,A
    815              }
    816          
    817          #if HAL_UART_ISR
    818          #if HAL_UART_DMA
    819              if ( cfg->flag & UART_CFG_DMA )
    820              {
    821                pollDMA( cfg );
    822              }
    823              else
    824          #endif
    825                {
    826                pollISR( cfg );
    827                }
    828          #elif HAL_UART_DMA
    829              pollDMA( cfg );
   \   00005B                ; Setup parameters for call to function pollDMA
   \   00005B   EE           MOV     A,R6
   \   00005C   FA           MOV     R2,A
   \   00005D   EF           MOV     A,R7
   \   00005E   FB           MOV     R3,A
   \   00005F   12....       LCALL   ??pollDMA?relay
    830          #endif
    831          
    832              /* The following logic makes continuous callbacks on any eligible flag
    833               * until the condition corresponding to the flag is rectified.
    834               * So even if new data is not received, continuous callbacks are made.
    835               */
    836                if ( cfg->rxHead != cfg->rxTail )
   \   000062   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   000065   6069         JZ      ??HalUARTPoll_6
    837                {
    838                uint8 evt;
    839          
    840                if ( cfg->rxHead >= (cfg->rxMax - SAFE_RX_MIN) )
   \   000067   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   00006A   4004         JC      ??HalUARTPoll_7
    841                {
    842                  evt = HAL_UART_RX_FULL;
   \   00006C   7A01         MOV     R2,#0x1
   \   00006E   803D         SJMP    ??HalUARTPoll_8
    843                }
    844                else if ( cfg->rxHigh && (cfg->rxHead >= cfg->rxHigh) )
   \                     ??HalUARTPoll_7:
   \   000070   8E82         MOV     DPL,R6
   \   000072   8F83         MOV     DPH,R7
   \   000074   A3           INC     DPTR
   \   000075   A3           INC     DPTR
   \   000076   A3           INC     DPTR
   \   000077   A3           INC     DPTR
   \   000078   A3           INC     DPTR
   \   000079   A3           INC     DPTR
   \   00007A   A3           INC     DPTR
   \   00007B   E0           MOVX    A,@DPTR
   \   00007C   6020         JZ      ??HalUARTPoll_9
   \   00007E   8E82         MOV     DPL,R6
   \   000080   8F83         MOV     DPH,R7
   \   000082   A3           INC     DPTR
   \   000083   A3           INC     DPTR
   \   000084   E0           MOVX    A,@DPTR
   \   000085   C0E0         PUSH    A
   \   000087   8E82         MOV     DPL,R6
   \   000089   8F83         MOV     DPH,R7
   \   00008B   A3           INC     DPTR
   \   00008C   A3           INC     DPTR
   \   00008D   A3           INC     DPTR
   \   00008E   A3           INC     DPTR
   \   00008F   A3           INC     DPTR
   \   000090   A3           INC     DPTR
   \   000091   A3           INC     DPTR
   \   000092   E0           MOVX    A,@DPTR
   \   000093   FA           MOV     R2,A
   \   000094   D0E0         POP     A
   \   000096   C3           CLR     C
   \   000097   9A           SUBB    A,R2
   \   000098   4004         JC      ??HalUARTPoll_9
    845                {
    846                  evt = HAL_UART_RX_ABOUT_FULL;
   \   00009A   7A02         MOV     R2,#0x2
   \   00009C   800F         SJMP    ??HalUARTPoll_8
    847              }
    848                else if ( cfg->rxTick == 0 )
   \                     ??HalUARTPoll_9:
   \   00009E   8E82         MOV     DPL,R6
   \   0000A0   8F83         MOV     DPH,R7
   \   0000A2   A3           INC     DPTR
   \   0000A3   A3           INC     DPTR
   \   0000A4   A3           INC     DPTR
   \   0000A5   A3           INC     DPTR
   \   0000A6   A3           INC     DPTR
   \   0000A7   A3           INC     DPTR
   \   0000A8   E0           MOVX    A,@DPTR
   \   0000A9   7025         JNZ     ??HalUARTPoll_6
    849              {
    850                  evt = HAL_UART_RX_TIMEOUT;
   \   0000AB   7A04         MOV     R2,#0x4
   \                     ??HalUARTPoll_8:
   \   0000AD   EE           MOV     A,R6
   \   0000AE   2410         ADD     A,#0x10
   \   0000B0   12....       LCALL   ??Subroutine7_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_30:
   \   0000B3   7002         JNZ     ??HalUARTPoll_10
   \   0000B5   A3           INC     DPTR
   \   0000B6   E0           MOVX    A,@DPTR
   \                     ??HalUARTPoll_10:
   \   0000B7   6017         JZ      ??HalUARTPoll_6
    851              }
    852              else
    853              {
    854                  evt = 0;
    855              }
    856          
    857              if ( evt && cfg->rxCB )
    858              {
    859                  cfg->rxCB( ((cfg->flag & UART_CFG_U1F)!=0), evt );
   \   0000B9                ; Setup parameters for indirect call
   \   0000B9   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   0000BC   E4           CLR     A
   \   0000BD   92E0         MOV     0xE0 /* A   */.0,C
   \   0000BF   F9           MOV     R1,A
   \   0000C0   EE           MOV     A,R6
   \   0000C1   2410         ADD     A,#0x10
   \   0000C3   F582         MOV     DPL,A
   \   0000C5   EF           MOV     A,R7
   \   0000C6   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   0000C9   F583         MOV     DPH,A
   \   0000CB   8882         MOV     DPL,R0
   \   0000CD   12....       LCALL   ?CALL_IND
    860              }
    861              }
    862          
    863          #if HAL_UART_0_ENABLE
    864              if ( cfg == cfg0 )
    865              {
    866          #if HAL_UART_1_ENABLE
    867                if ( cfg1 )
    868                {
    869                  cfg = cfg1;
    870                }
    871                else
    872          #endif
    873                  break;
    874              }
    875              else
    876          #endif
    877                break;
    878          
    879            } while ( TRUE );
    880          #else
    881            return;
    882          #endif
    883          }
   \                     ??HalUARTPoll_6:
   \   0000D0   7F01         MOV     R7,#0x1
   \   0000D2   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   0000D5                REQUIRE ST0

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     ??tickShdw:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    884          
    885          /**************************************************************************************************
    886           * @fn      Hal_UART_RxBufLen()
    887           *
    888           * @brief   Calculate Rx Buffer length - the number of bytes in the buffer.
    889           *
    890           * @param   port - UART port
    891           *
    892           * @return  length of current Rx Buffer
    893           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    894          uint16 Hal_UART_RxBufLen( uint8 port )
   \                     Hal_UART_RxBufLen:
    895          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
    896            uartCfg_t *cfg = NULL;
   \   000005   7800         MOV     R0,#0x0
   \   000007   7900         MOV     R1,#0x0
    897          
    898          #if HAL_UART_0_ENABLE
    899            if ( port == HAL_UART_PORT_0 )
   \   000009   7008         JNZ     ??Hal_UART_RxBufLen_0
    900            {
    901              cfg = cfg0;
   \   00000B   90....       MOV     DPTR,#cfg0
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   F8           MOV     R0,A
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   F9           MOV     R1,A
    902            }
    903          #endif
    904          #if HAL_UART_1_ENABLE
    905            if ( port == HAL_UART_PORT_1 )
    906            {
    907              cfg = cfg1;
    908            }
    909          #endif
    910          
    911            HAL_UART_ASSERT( cfg );
    912          
    913            return UART_RX_AVAIL( cfg );
   \                     ??Hal_UART_RxBufLen_0:
   \   000013   8882         MOV     DPL,R0
   \   000015   8983         MOV     DPH,R1
   \   000017   A3           INC     DPTR
   \   000018   A3           INC     DPTR
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   C0E0         PUSH    A
   \   00001C   8882         MOV     DPL,R0
   \   00001E   8983         MOV     DPH,R1
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   E0           MOVX    A,@DPTR
   \   000024   FA           MOV     R2,A
   \   000025   D0E0         POP     A
   \   000027   C3           CLR     C
   \   000028   9A           SUBB    A,R2
   \   000029   8882         MOV     DPL,R0
   \   00002B   8983         MOV     DPH,R1
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   400D         JC      ??Hal_UART_RxBufLen_1
   \   000031   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_72:
   \   000034   F8           MOV     R0,A
   \   000035   EA           MOV     A,R2
   \   000036   C3           CLR     C
   \   000037   98           SUBB    A,R0
   \   000038   FA           MOV     R2,A
   \   000039   E4           CLR     A
   \   00003A   9400         SUBB    A,#0x0
   \   00003C   8020         SJMP    ??Hal_UART_RxBufLen_2
   \                     ??Hal_UART_RxBufLen_1:
   \   00003E   A3           INC     DPTR
   \   00003F   A3           INC     DPTR
   \   000040   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_73:
   \   000043   FC           MOV     R4,A
   \   000044   EA           MOV     A,R2
   \   000045   C3           CLR     C
   \   000046   9C           SUBB    A,R4
   \   000047   FA           MOV     R2,A
   \   000048   E4           CLR     A
   \   000049   9400         SUBB    A,#0x0
   \   00004B   FB           MOV     R3,A
   \   00004C   8882         MOV     DPL,R0
   \   00004E   8983         MOV     DPH,R1
   \   000050   A3           INC     DPTR
   \   000051   A3           INC     DPTR
   \   000052   E0           MOVX    A,@DPTR
   \   000053   2A           ADD     A,R2
   \   000054   F8           MOV     R0,A
   \   000055   E4           CLR     A
   \   000056   3B           ADDC    A,R3
   \   000057   F9           MOV     R1,A
   \   000058   7401         MOV     A,#0x1
   \   00005A   28           ADD     A,R0
   \   00005B   FA           MOV     R2,A
   \   00005C   E4           CLR     A
   \   00005D   39           ADDC    A,R1
   \                     ??Hal_UART_RxBufLen_2:
   \   00005E   FB           MOV     R3,A
   \   00005F   02....       LJMP    ?Subroutine23 & 0xFFFF
    914          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   8882         MOV     DPL,R0
   \   000004   8983         MOV     DPH,R1
   \   000006   02....       LJMP    ?Subroutine22 & 0xFFFF
    915          
    916          /*****************************************************************************
    917           * @fn      HalUARTRead
    918           *
    919           * @brief   Read a buffer from the UART
    920           *
    921           * @param   port - USART module designation
    922           *          buf  - valid data buffer at least 'len' bytes in size
    923           *          len  - max length number of bytes to copy to 'buf'
    924           *
    925           * @return  length of buffer that was read
    926           *****************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    927          uint16 HalUARTRead( uint8 port, uint8 *buf, uint16 len )
   \                     HalUARTRead:
    928          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
    929            uartCfg_t *cfg = NULL;
   \   000006   7800         MOV     R0,#0x0
   \   000008   7900         MOV     R1,#0x0
    930            uint8 cnt = 0;
   \   00000A   88..         MOV     ?V0 + 2,R0
    931          
    932          #if HAL_UART_0_ENABLE
    933            if ( port == HAL_UART_PORT_0 )
   \   00000C   7016         JNZ     ??HalUARTRead_0
    934            {
    935              cfg = cfg0;
   \   00000E   90....       MOV     DPTR,#cfg0
   \   000011   E0           MOVX    A,@DPTR
   \   000012   F8           MOV     R0,A
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F9           MOV     R1,A
   \   000016   800C         SJMP    ??HalUARTRead_0
    936            }
    937          #endif
    938          #if HAL_UART_1_ENABLE
    939            if ( port == HAL_UART_PORT_1 )
    940            {
    941              cfg = cfg1;
    942            }
    943          #endif
    944          
    945            HAL_UART_ASSERT( cfg );
    946          
    947            while ( (cfg->rxTail != cfg->rxHead) && (cnt < len) )
    948            {
    949              *buf++ = cfg->rxBuf[cfg->rxTail];
    950              if ( cfg->rxTail == cfg->rxMax )
    951              {
    952                cfg->rxTail = 0;
    953              }
    954              else
    955              {
    956                cfg->rxTail++;
   \                     ??HalUARTRead_1:
   \   000018   8882         MOV     DPL,R0
   \   00001A   8983         MOV     DPH,R1
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   04           INC     A
   \                     ??HalUARTRead_2:
   \   000021   F0           MOVX    @DPTR,A
    957              }
    958              cnt++;
   \   000022   05..         INC     ?V0 + 2
   \                     ??HalUARTRead_0:
   \   000024   8882         MOV     DPL,R0
   \   000026   8983         MOV     DPH,R1
   \   000028   A3           INC     DPTR
   \   000029   A3           INC     DPTR
   \   00002A   A3           INC     DPTR
   \   00002B   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_45:
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   6E           XRL     A,R6
   \   000030   604E         JZ      ??HalUARTRead_3
   \   000032   85....       MOV     ?V0 + 0,?V0 + 2
   \   000035   C3           CLR     C
   \   000036   E5..         MOV     A,?V0 + 0
   \   000038   9C           SUBB    A,R4
   \   000039   E4           CLR     A
   \   00003A   9D           SUBB    A,R5
   \   00003B   5043         JNC     ??HalUARTRead_3
   \   00003D   E8           MOV     A,R0
   \   00003E   2403         ADD     A,#0x3
   \   000040   FE           MOV     R6,A
   \   000041   E9           MOV     A,R1
   \   000042   3400         ADDC    A,#0x0
   \   000044   FF           MOV     R7,A
   \   000045   8E82         MOV     DPL,R6
   \   000047   8F83         MOV     DPH,R7
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   F5..         MOV     ?V0 + 0,A
   \   00004C   8882         MOV     DPL,R0
   \   00004E   8983         MOV     DPH,R1
   \   000050   E0           MOVX    A,@DPTR
   \   000051   25..         ADD     A,?V0 + 0
   \   000053   F5..         MOV     ?V0 + 3,A
   \   000055   A3           INC     DPTR
   \   000056   E0           MOVX    A,@DPTR
   \   000057   3400         ADDC    A,#0x0
   \   000059   85..82       MOV     DPL,?V0 + 3
   \   00005C   F583         MOV     DPH,A
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   8A82         MOV     DPL,R2
   \   000061   8B83         MOV     DPH,R3
   \   000063   F0           MOVX    @DPTR,A
   \   000064   A3           INC     DPTR
   \   000065   AA82         MOV     R2,DPL
   \   000067   AB83         MOV     R3,DPH
   \   000069   8E82         MOV     DPL,R6
   \   00006B   8F83         MOV     DPH,R7
   \   00006D   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   000070   A3           INC     DPTR
   \   000071   A3           INC     DPTR
   \   000072   E0           MOVX    A,@DPTR
   \   000073   6E           XRL     A,R6
   \   000074   70A2         JNZ     ??HalUARTRead_1
   \   000076   E4           CLR     A
   \   000077   8882         MOV     DPL,R0
   \   000079   8983         MOV     DPH,R1
   \   00007B   A3           INC     DPTR
   \   00007C   A3           INC     DPTR
   \   00007D   A3           INC     DPTR
   \   00007E   80A1         SJMP    ??HalUARTRead_2
    959            }
    960          
    961          #if HAL_UART_DMA
    962            #if HAL_UART_ISR
    963            if ( cfg->flag & UART_CFG_DMA )
    964            #endif
    965            {
    966              /* If there is no flow control on a DMA-driven UART, the Rx Head & Tail
    967               * pointers must be reset to zero after every read in order to preserve the
    968               * full length of the Rx buffer. This implies that every Read must read all
    969               * of the Rx bytes available, or the pointers will not be reset and the
    970               * next incoming packet may not fit in the Rx buffer space remaining - thus
    971               * the end portion of the incoming packet that does not fit would be lost.
    972               */
    973              if ( !(cfg->flag & UART_CFG_FLW) )
   \                     ??HalUARTRead_3:
   \   000080   E8           MOV     A,R0
   \   000081   240F         ADD     A,#0xf
   \   000083   F582         MOV     DPL,A
   \   000085   E9           MOV     A,R1
   \   000086   12....       LCALL   ??Subroutine7_1 & 0xFFFF
   \                     ??CrossCallReturnLabel_31:
   \   000089   A2E5         MOV     C,0xE0 /* A   */.5
   \   00008B   4003         JC      ??HalUARTRead_4
    974              {
    975                // This is a trick to trigger the DMA abort and restart logic in pollDMA.
    976                cfg->flag |= UART_CFG_RXF;
   \   00008D   D2E1         SETB    0xE0 /* A   */.1
   \   00008F   F0           MOVX    @DPTR,A
    977              }
    978            }
    979          #endif
    980          
    981          #if HAL_UART_ISR
    982            #if HAL_UART_DMA
    983            if ( !(cfg->flag & UART_CFG_DMA) )
    984            #endif
    985            {
    986              cfg->rxCnt = UART_RX_AVAIL( cfg );
    987          
    988              if ( cfg->flag & UART_CFG_RXF )
    989              {
    990                if ( cfg->rxCnt < (cfg->rxMax - SAFE_RX_MIN) )
    991                {
    992                  RX_STRT_FLOW( cfg );
    993                }
    994              }
    995            }
    996          #endif
    997          
    998            return cnt;
   \                     ??HalUARTRead_4:
   \   000090   AA..         MOV     R2,?V0 + 2
   \   000092   7B00         MOV     R3,#0x0
   \   000094                REQUIRE ?Subroutine24
   \   000094                ; // Fall through to label ?Subroutine24
    999          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FE           MOV     R6,A
   \   000002   8882         MOV     DPL,R0
   \   000004   8983         MOV     DPH,R1
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   22           RET
   1000          
   1001          /******************************************************************************
   1002           * @fn      HalUARTWrite
   1003           *
   1004           * @brief   Write a buffer to the UART.
   1005           *
   1006           * @param   port    - UART port
   1007           *          pBuffer - pointer to the buffer that will be written, not freed
   1008           *          length  - length of
   1009           *
   1010           * @return  length of the buffer that was sent
   1011           *****************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1012          uint16 HalUARTWrite( uint8 port, uint8 *buf, uint16 len )
   \                     HalUARTWrite:
   1013          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 0,R1
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
   \   00000B   EC           MOV     A,R4
   \   00000C   FA           MOV     R2,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FB           MOV     R3,A
   1014            uartCfg_t *cfg = NULL;
   \   00000F   7800         MOV     R0,#0x0
   \   000011   7900         MOV     R1,#0x0
   1015            uint8 cnt;
   1016          
   1017          #if HAL_UART_0_ENABLE
   1018            if ( port == HAL_UART_PORT_0 )
   \   000013   E5..         MOV     A,?V0 + 0
   \   000015   7008         JNZ     ??HalUARTWrite_0
   1019            {
   1020              cfg = cfg0;
   \   000017   90....       MOV     DPTR,#cfg0
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   F8           MOV     R0,A
   \   00001C   A3           INC     DPTR
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   F9           MOV     R1,A
   1021            }
   1022          #endif
   1023          #if HAL_UART_1_ENABLE
   1024            if ( port == HAL_UART_PORT_1 )
   1025            {
   1026              cfg = cfg1;
   1027            }
   1028          #endif
   1029          
   1030            HAL_UART_ASSERT( cfg );
   1031          
   1032            if ( cfg->txHead == cfg->txTail )
   \                     ??HalUARTWrite_0:
   \   00001F   8882         MOV     DPL,R0
   \   000021   8983         MOV     DPH,R1
   \   000023   A3           INC     DPTR
   \   000024   A3           INC     DPTR
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   A3           INC     DPTR
   \   000029   A3           INC     DPTR
   \   00002A   A3           INC     DPTR
   \   00002B   A3           INC     DPTR
   \   00002C   A3           INC     DPTR
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   FC           MOV     R4,A
   \   00002F   E8           MOV     A,R0
   \   000030   240B         ADD     A,#0xb
   \   000032   F582         MOV     DPL,A
   \   000034   E9           MOV     A,R1
   \   000035   12....       LCALL   ??Subroutine7_1 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   000038   6C           XRL     A,R4
   \   000039   7021         JNZ     ??HalUARTWrite_1
   1033            {
   1034          #if HAL_UART_DMA
   1035              // When pointers are equal, reset to zero to get max len w/out wrapping.
   1036              cfg->txHead = cfg->txTail = 0;
   \   00003B   E4           CLR     A
   \   00003C   F0           MOVX    @DPTR,A
   \   00003D   8882         MOV     DPL,R0
   \   00003F   8983         MOV     DPH,R1
   \   000041   A3           INC     DPTR
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   F0           MOVX    @DPTR,A
   \   00004C   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   00004F   74FF         MOV     A,#-0x1
   \   000051   2C           ADD     A,R4
   \   000052   F5..         MOV     ?V0 + 0,A
   \   000054   74FF         MOV     A,#-0x1
   \   000056   3400         ADDC    A,#0x0
   \   000058   F5..         MOV     ?V0 + 1,A
   \   00005A   8040         SJMP    ??HalUARTWrite_2
   1037          #endif
   1038          #if HAL_UART_ISR
   1039          #if HAL_UART_DMA
   1040              if ( !(cfg->flag & UART_CFG_DMA) )
   1041          #endif
   1042              {
   1043                cfg->flag &= ~UART_CFG_TXF;
   1044              }
   1045          #endif
   1046            }
   1047          
   1048            // Accept "all-or-none" on write request.
   1049            if ( TX_AVAIL( cfg ) < len )
   \                     ??HalUARTWrite_1:
   \   00005C   8882         MOV     DPL,R0
   \   00005E   8983         MOV     DPH,R1
   \   000060   A3           INC     DPTR
   \   000061   A3           INC     DPTR
   \   000062   A3           INC     DPTR
   \   000063   A3           INC     DPTR
   \   000064   A3           INC     DPTR
   \   000065   A3           INC     DPTR
   \   000066   A3           INC     DPTR
   \   000067   A3           INC     DPTR
   \   000068   A3           INC     DPTR
   \   000069   A3           INC     DPTR
   \   00006A   E0           MOVX    A,@DPTR
   \   00006B   C0E0         PUSH    A
   \   00006D   E8           MOV     A,R0
   \   00006E   240B         ADD     A,#0xb
   \   000070   12....       LCALL   ??Subroutine5_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   000073   D0E0         POP     A
   \   000075   C3           CLR     C
   \   000076   9C           SUBB    A,R4
   \   000077   500B         JNC     ??HalUARTWrite_3
   \   000079   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   00007C   74FF         MOV     A,#-0x1
   \   00007E   2C           ADD     A,R4
   \   00007F   1C           DEC     R4
   \   000080   74FF         MOV     A,#-0x1
   \   000082   8012         SJMP    ??HalUARTWrite_4
   \                     ??HalUARTWrite_3:
   \   000084   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   000087   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   00008A   E8           MOV     A,R0
   \   00008B   240B         ADD     A,#0xb
   \   00008D   F582         MOV     DPL,A
   \   00008F   E9           MOV     A,R1
   \   000090   12....       LCALL   ??Subroutine7_1 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   000093   2C           ADD     A,R4
   \   000094   FC           MOV     R4,A
   \   000095   E4           CLR     A
   \                     ??HalUARTWrite_4:
   \   000096   3D           ADDC    A,R5
   \   000097   FD           MOV     R5,A
   \   000098   8C..         MOV     ?V0 + 0,R4
   \   00009A   8D..         MOV     ?V0 + 1,R5
   \                     ??HalUARTWrite_2:
   \   00009C   C3           CLR     C
   \   00009D   E5..         MOV     A,?V0 + 0
   \   00009F   9A           SUBB    A,R2
   \   0000A0   E5..         MOV     A,?V0 + 1
   \   0000A2   9B           SUBB    A,R3
   \   0000A3   5006         JNC     ??HalUARTWrite_5
   1050            {
   1051              return 0;
   \   0000A5   7A00         MOV     R2,#0x0
   \   0000A7   7B00         MOV     R3,#0x0
   \   0000A9   8078         SJMP    ??HalUARTWrite_6
   1052            }
   1053          
   1054            for ( cnt = len; cnt; cnt-- )
   \                     ??HalUARTWrite_5:
   \   0000AB   EA           MOV     A,R2
   \   0000AC   F5..         MOV     ?V0 + 3,A
   \   0000AE   8013         SJMP    ??HalUARTWrite_7
   1055            {
   1056              cfg->txBuf[ cfg->txHead ] = *buf++;
   1057          
   1058              if ( cfg->txHead == cfg->txMax )
   1059              {
   1060                cfg->txHead = 0;
   1061              }
   1062              else
   1063              {
   1064                cfg->txHead++;
   \                     ??HalUARTWrite_8:
   \   0000B0   8882         MOV     DPL,R0
   \   0000B2   8983         MOV     DPH,R1
   \   0000B4   A3           INC     DPTR
   \   0000B5   A3           INC     DPTR
   \   0000B6   A3           INC     DPTR
   \   0000B7   A3           INC     DPTR
   \   0000B8   A3           INC     DPTR
   \   0000B9   A3           INC     DPTR
   \   0000BA   A3           INC     DPTR
   \   0000BB   A3           INC     DPTR
   \   0000BC   A3           INC     DPTR
   \   0000BD   A3           INC     DPTR
   \   0000BE   E0           MOVX    A,@DPTR
   \   0000BF   04           INC     A
   \                     ??HalUARTWrite_9:
   \   0000C0   F0           MOVX    @DPTR,A
   1065              }
   \   0000C1   15..         DEC     ?V0 + 3
   \                     ??HalUARTWrite_7:
   \   0000C3   E5..         MOV     A,?V0 + 3
   \   0000C5   605C         JZ      ??HalUARTWrite_6
   \   0000C7   E8           MOV     A,R0
   \   0000C8   240A         ADD     A,#0xa
   \   0000CA   FC           MOV     R4,A
   \   0000CB   E9           MOV     A,R1
   \   0000CC   3400         ADDC    A,#0x0
   \   0000CE   FD           MOV     R5,A
   \   0000CF   8E82         MOV     DPL,R6
   \   0000D1   8F83         MOV     DPH,R7
   \   0000D3   E0           MOVX    A,@DPTR
   \   0000D4   C0E0         PUSH    A
   \   0000D6   8C82         MOV     DPL,R4
   \   0000D8   8D83         MOV     DPH,R5
   \   0000DA   E0           MOVX    A,@DPTR
   \   0000DB   F5..         MOV     ?V0 + 0,A
   \   0000DD   8882         MOV     DPL,R0
   \   0000DF   8983         MOV     DPH,R1
   \   0000E1   A3           INC     DPTR
   \   0000E2   A3           INC     DPTR
   \   0000E3   A3           INC     DPTR
   \   0000E4   A3           INC     DPTR
   \   0000E5   A3           INC     DPTR
   \   0000E6   A3           INC     DPTR
   \   0000E7   A3           INC     DPTR
   \   0000E8   A3           INC     DPTR
   \   0000E9   E0           MOVX    A,@DPTR
   \   0000EA   25..         ADD     A,?V0 + 0
   \   0000EC   F5..         MOV     ?V0 + 2,A
   \   0000EE   A3           INC     DPTR
   \   0000EF   E0           MOVX    A,@DPTR
   \   0000F0   3400         ADDC    A,#0x0
   \   0000F2   85..82       MOV     DPL,?V0 + 2
   \   0000F5   F583         MOV     DPH,A
   \   0000F7   D0E0         POP     A
   \   0000F9   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   0000FC   AE82         MOV     R6,DPL
   \   0000FE   AF83         MOV     R7,DPH
   \   000100   8C82         MOV     DPL,R4
   \   000102   8D83         MOV     DPH,R5
   \   000104   E0           MOVX    A,@DPTR
   \   000105   FC           MOV     R4,A
   \   000106   E8           MOV     A,R0
   \   000107   240C         ADD     A,#0xc
   \   000109   F582         MOV     DPL,A
   \   00010B   E9           MOV     A,R1
   \   00010C   12....       LCALL   ??Subroutine7_1 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   00010F   6C           XRL     A,R4
   \   000110   709E         JNZ     ??HalUARTWrite_8
   \   000112   E4           CLR     A
   \   000113   8882         MOV     DPL,R0
   \   000115   8983         MOV     DPH,R1
   \   000117   A3           INC     DPTR
   \   000118   A3           INC     DPTR
   \   000119   A3           INC     DPTR
   \   00011A   A3           INC     DPTR
   \   00011B   A3           INC     DPTR
   \   00011C   A3           INC     DPTR
   \   00011D   A3           INC     DPTR
   \   00011E   A3           INC     DPTR
   \   00011F   A3           INC     DPTR
   \   000120   A3           INC     DPTR
   \   000121   809D         SJMP    ??HalUARTWrite_9
   1066            }
   1067          
   1068          #if HAL_UART_ISR
   1069          #if HAL_UART_DMA
   1070            if ( !(cfg->flag & UART_CFG_DMA) )
   1071          #endif
   1072            {
   1073              if ( !(cfg->flag & UART_CFG_TXF) && len )
   1074              {
   1075                cfg->flag |= UART_CFG_TXF;
   1076                if ( !(cfg->flag & UART_CFG_U1F) )
   1077                {
   1078                  U0DBUF = cfg->txBuf[cfg->txTail];
   1079                }
   1080                else
   1081                {
   1082                  U1DBUF = cfg->txBuf[cfg->txTail];
   1083                }
   1084              }
   1085            }
   1086          #endif
   1087          
   1088            return len;
   \                     ??HalUARTWrite_6:
   \   000123   02....       LJMP    ?Subroutine24 & 0xFFFF
   1089          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   8882         MOV     DPL,R0
   \   000002   8983         MOV     DPH,R1
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   F5..         MOV     ?V0 + 0,A
   \   000011   EC           MOV     A,R4
   \   000012   C3           CLR     C
   \   000013   95..         SUBB    A,?V0 + 0
   \   000015   FC           MOV     R4,A
   \   000016   E4           CLR     A
   \   000017   9400         SUBB    A,#0x0
   \   000019   FD           MOV     R5,A
   \   00001A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   E8           MOV     A,R0
   \   000001   240C         ADD     A,#0xc
   \                     ??Subroutine5_0:
   \   000003   F582         MOV     DPL,A
   \   000005   E9           MOV     A,R1
   \   000006   12....       LCALL   ??Subroutine20_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   000009   FC           MOV     R4,A
   \   00000A   22           RET

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??pollDMA?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    pollDMA

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalUARTInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalUARTInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalUARTOpen?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalUARTOpen

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalUARTClose?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalUARTClose

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalUARTPoll?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalUARTPoll

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??Hal_UART_RxBufLen?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    Hal_UART_RxBufLen

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalUARTRead?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalUARTRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalUARTWrite?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalUARTWrite
   1090          
   1091          #if HAL_UART_ISR
   1092          /***************************************************************************************************
   1093           * @fn      halUart0RxIsr
   1094           *
   1095           * @brief   UART0 Receive Interrupt
   1096           *
   1097           * @param   None
   1098           *
   1099           * @return  None
   1100           ***************************************************************************************************/
   1101          #if HAL_UART_0_ENABLE
   1102          HAL_ISR_FUNCTION( halUart0RxIsr, URX0_VECTOR )
   1103          {
   1104            cfg0->rxBuf[cfg0->rxHead] = U0DBUF;
   1105          
   1106            if ( cfg0->rxHead == cfg0->rxMax )
   1107            {
   1108              cfg0->rxHead = 0;
   1109            }
   1110            else
   1111            {
   1112              cfg0->rxHead++;
   1113            }
   1114          }
   1115          #endif
   1116          
   1117          /***************************************************************************************************
   1118           * @fn      halUart1RxIsr
   1119           *
   1120           * @brief   UART1 Receive Interrupt
   1121           *
   1122           * @param   None
   1123           *
   1124           * @return  None
   1125           ***************************************************************************************************/
   1126          #if HAL_UART_1_ENABLE
   1127          HAL_ISR_FUNCTION( halUart1RxIsr, URX1_VECTOR )
   1128          {
   1129            cfg1->rxBuf[cfg1->rxHead] = U1DBUF;
   1130          
   1131            if ( cfg1->rxHead == cfg1->rxMax )
   1132            {
   1133              cfg1->rxHead = 0;
   1134            }
   1135            else
   1136            {
   1137              cfg1->rxHead++;
   1138            }
   1139          }
   1140          #endif
   1141          
   1142          /***************************************************************************************************
   1143           * @fn      halUart0TxIsr
   1144           *
   1145           * @brief   UART0 Transmit Interrupt
   1146           *
   1147           * @param   None
   1148           *
   1149           * @return  None
   1150           ***************************************************************************************************/
   1151          #if HAL_UART_0_ENABLE
   1152          HAL_ISR_FUNCTION( halUart0TxIsr, UTX0_VECTOR )
   1153          {
   1154            UTX0IF = 0;
   1155          
   1156            if ( cfg0->txTail == cfg0->txMax )
   1157            {
   1158              cfg0->txTail = 0;
   1159            }
   1160            else
   1161            {
   1162              cfg0->txTail++;
   1163            }
   1164          
   1165            if ( cfg0->txTail != cfg0->txHead )
   1166            {
   1167              U0DBUF = cfg0->txBuf[cfg0->txTail];
   1168            }
   1169          }
   1170          #endif
   1171          
   1172          /***************************************************************************************************
   1173           * @fn      halUart1TxIsr
   1174           *
   1175           * @brief   UART1 Transmit Interrupt
   1176           *
   1177           * @param   None
   1178           *
   1179           * @return  None
   1180           ***************************************************************************************************/
   1181          #if HAL_UART_1_ENABLE
   1182          HAL_ISR_FUNCTION( halUart1TxIsr, UTX1_VECTOR )
   1183          {
   1184            UTX1IF = 0;
   1185            U1CSR &= ~CSR_TX_BYTE;  // Rev-D does not require, older does.
   1186          
   1187            if ( cfg1->txTail == cfg1->txMax )
   1188            {
   1189              cfg1->txTail = 0;
   1190            }
   1191            else
   1192            {
   1193              cfg1->txTail++;
   1194            }
   1195          
   1196            if ( cfg1->txTail != cfg1->txHead )
   1197            {
   1198              U1DBUF = cfg1->txBuf[cfg1->txTail];
   1199            }
   1200          }
   1201          #endif
   1202          #endif
   1203          
   1204          /******************************************************************************
   1205          ******************************************************************************/

   Maximum stack usage in bytes:

     Function            ISTACK PSTACK XSTACK
     --------            ------ ------ ------
     HalUARTClose            0      0      0
     HalUARTInit             2      0      0
     HalUARTOpen             1      0     15
       -> osal_mem_alloc     0      0     30
       -> osal_mem_alloc     0      0     30
       -> osal_mem_alloc     0      0     30
       -> osal_memset        0      0     30
     HalUARTPoll             1      0      9
       -> pollDMA            0      0     18
     HalUARTRead             1      0     12
     HalUARTWrite            1      0     12
     Hal_UART_RxBufLen       3      0      0
     pollDMA                 1      0     20
       -> osal_memset        0      0     22


   Segment part sizes:

     Function/Label            Bytes
     --------------            -----
     _A_P0                        1
     U0CSR                        1
     _A_P1                        1
     ST0                          1
     U0DBUF                       1
     U0BAUD                       1
     U0UCR                        1
     U0GCR                        1
     DMAIRQ                       1
     DMAARM                       1
     DMAREQ                       1
     PERCFG                       1
     ADCCFG                       1
     P0SEL                        1
     P0DIR                        1
     P2DIR                        1
     cfg0                         2
     pollDMA                    530
     ?Subroutine4                11
     ?Subroutine2                 8
     ?Subroutine0                10
     ?Subroutine22                5
     ?Subroutine21               10
     ?Subroutine16               15
     ?Subroutine10               29
     ?Subroutine9                18
     ?Subroutine8                19
     ?Subroutine19                7
     ?Subroutine12               12
     ?Subroutine18               10
     ?Subroutine3                 9
     ?Subroutine1                30
     ?Subroutine7                10
     ?Subroutine20                9
     HalUARTInit                 93
     ?Subroutine23                7
     HalUARTOpen                306
     ?Subroutine17               13
     ?Subroutine15                9
     ?Subroutine6                 7
     HalUARTClose                 3
     HalUARTPoll                213
     tickShdw                     1
     Hal_UART_RxBufLen           98
     ?Subroutine13                9
     HalUARTRead                148
     ?Subroutine24                5
     ?Subroutine14                9
     HalUARTWrite               294
     ?Subroutine11               27
     ?Subroutine5                11
     ??pollDMA?relay              6
     ??HalUARTInit?relay          6
     ??HalUARTOpen?relay          6
     ??HalUARTClose?relay         6
     ??HalUARTPoll?relay          6
     ??Hal_UART_RxBufLen?relay    6
     ??HalUARTRead?relay          6
     ??HalUARTWrite?relay         6

 
 1 994 bytes in segment BANKED_CODE
    48 bytes in segment BANK_RELAYS
    16 bytes in segment SFR_AN
     3 bytes in segment XDATA_Z
 
 2 042 bytes of CODE  memory
     0 bytes of DATA  memory (+ 16 bytes shared)
     3 bytes of XDATA memory

Errors: none
Warnings: none
