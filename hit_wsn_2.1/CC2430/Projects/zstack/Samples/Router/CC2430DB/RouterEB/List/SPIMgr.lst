###############################################################################
#                                                                             #
# IAR 8051 C/C++ Compiler V7.30B/W32                    30/May/2011  19:00:08 #
# Copyright 2004-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Documents and Settings\Administrator\×ÀÃæ\proje #
#                          ct\513\hit_wsn_2.0\Components\mt\SPIMgr.c          #
#    Command line       =  -f "C:\Documents and Settings\Administrator\×ÀÃæ\p #
#                          roject\513\hit_wsn_2.0\Projects\zstack\Samples\Rou #
#                          ter_v2\CC2430DB\..\..\..\Tools\CC2430DB\f8wRouter. #
#                          cfg" (-DCPU32MHZ -DFORCE_MAC_NEAR                  #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                          E -DRTR_NWK -DBLINK_LEDS "-DCONST=const __code"    #
#                          -DGENERIC=__generic) -f "C:\Documents and          #
#                          Settings\Administrator\×ÀÃæ\project\513\hit_wsn_2. #
#                          0\Projects\zstack\Samples\Router_v2\CC2430DB\..\.. #
#                          \..\Tools\CC2430DB\f8wConfig.cfg" (-DSECURE=0      #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=10 -DAPSC_MAX_FRAME_RETRIES=3   #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=20           #
#                          -DNWK_MAX_BINDING_ENTRIES=10                       #
#                          -DMAX_BINDING_CLUSTER_IDS=5 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 "C:\Documents and           #
#                          Settings\Administrator\×ÀÃæ\project\513\hit_wsn_2. #
#                          0\Components\mt\SPIMgr.c" -D CC2430EB -D           #
#                          REFLECTOR -D ZTOOL_P1 -D MT_TASK -D MT_ZDO_FUNC    #
#                          -D LCD_SUPPORTED=DEBUG -lC "C:\Documents and       #
#                          Settings\Administrator\×ÀÃæ\project\513\hit_wsn_2. #
#                          0\Projects\zstack\Samples\Router_v2\CC2430DB\Route #
#                          rEB\List\" -lA "C:\Documents and                   #
#                          Settings\Administrator\×ÀÃæ\project\513\hit_wsn_2. #
#                          0\Projects\zstack\Samples\Router_v2\CC2430DB\Route #
#                          rEB\List\" --diag_suppress Pe001,Pa010             #
#                          --diag_remark pe550 -o "C:\Documents and           #
#                          Settings\Administrator\×ÀÃæ\project\513\hit_wsn_2. #
#                          0\Projects\zstack\Samples\Router_v2\CC2430DB\Route #
#                          rEB\Obj\" -e -z9 --no_code_motion --debug          #
#                          --core=plain --dptr=16,1 --data_model=large        #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data --nr_virtual_regs 8  #
#                          -I "C:\Documents and Settings\Administrator\×ÀÃæ\p #
#                          roject\513\hit_wsn_2.0\Projects\zstack\Samples\Rou #
#                          ter_v2\CC2430DB\" -I "C:\Documents and             #
#                          Settings\Administrator\×ÀÃæ\project\513\hit_wsn_2. #
#                          0\Projects\zstack\Samples\Router_v2\CC2430DB\..\SO #
#                          URCE\" -I "C:\Documents and                        #
#                          Settings\Administrator\×ÀÃæ\project\513\hit_wsn_2. #
#                          0\Projects\zstack\Samples\Router_v2\CC2430DB\..\.. #
#                          \..\ZMAIN\TI2430DB\" -I "C:\Documents and          #
#                          Settings\Administrator\×ÀÃæ\project\513\hit_wsn_2. #
#                          0\Projects\zstack\Samples\Router_v2\CC2430DB\..\.. #
#                          \..\..\..\COMPONENTS\MT\" -I "C:\Documents and     #
#                          Settings\Administrator\×ÀÃæ\project\513\hit_wsn_2. #
#                          0\Projects\zstack\Samples\Router_v2\CC2430DB\..\.. #
#                          \..\..\..\COMPONENTS\HAL\INCLUDE\" -I              #
#                          "C:\Documents and Settings\Administrator\×ÀÃæ\proj #
#                          ect\513\hit_wsn_2.0\Projects\zstack\Samples\Router #
#                          _v2\CC2430DB\..\..\..\..\..\COMPONENTS\HAL\TARGET\ #
#                          CC2430EB\" -I "C:\Documents and                    #
#                          Settings\Administrator\×ÀÃæ\project\513\hit_wsn_2. #
#                          0\Projects\zstack\Samples\Router_v2\CC2430DB\..\.. #
#                          \..\..\..\COMPONENTS\OSAL\MCU\CCSOC\" -I           #
#                          "C:\Documents and Settings\Administrator\×ÀÃæ\proj #
#                          ect\513\hit_wsn_2.0\Projects\zstack\Samples\Router #
#                          _v2\CC2430DB\..\..\..\..\..\COMPONENTS\OSAL\INCLUD #
#                          E\" -I "C:\Documents and                           #
#                          Settings\Administrator\×ÀÃæ\project\513\hit_wsn_2. #
#                          0\Projects\zstack\Samples\Router_v2\CC2430DB\..\.. #
#                          \..\..\..\COMPONENTS\STACK\AF\" -I "C:\Documents   #
#                          and Settings\Administrator\×ÀÃæ\project\513\hit_ws #
#                          n_2.0\Projects\zstack\Samples\Router_v2\CC2430DB\. #
#                          .\..\..\..\..\COMPONENTS\STACK\NWK\" -I            #
#                          "C:\Documents and Settings\Administrator\×ÀÃæ\proj #
#                          ect\513\hit_wsn_2.0\Projects\zstack\Samples\Router #
#                          _v2\CC2430DB\..\..\..\..\..\COMPONENTS\STACK\SEC\" #
#                           -I "C:\Documents and Settings\Administrator\×ÀÃæ\ #
#                          project\513\hit_wsn_2.0\Projects\zstack\Samples\Ro #
#                          uter_v2\CC2430DB\..\..\..\..\..\COMPONENTS\STACK\S #
#                          YS\" -I "C:\Documents and                          #
#                          Settings\Administrator\×ÀÃæ\project\513\hit_wsn_2. #
#                          0\Projects\zstack\Samples\Router_v2\CC2430DB\..\.. #
#                          \..\..\..\COMPONENTS\STACK\ZDO\" -I "C:\Documents  #
#                          and Settings\Administrator\×ÀÃæ\project\513\hit_ws #
#                          n_2.0\Projects\zstack\Samples\Router_v2\CC2430DB\. #
#                          .\..\..\..\..\COMPONENTS\ZMAC\F8W\" -I             #
#                          "C:\Documents and Settings\Administrator\×ÀÃæ\proj #
#                          ect\513\hit_wsn_2.0\Projects\zstack\Samples\Router #
#                          _v2\CC2430DB\..\..\..\..\..\COMPONENTS\ZMAC\" -I   #
#                          "C:\Documents and Settings\Administrator\×ÀÃæ\proj #
#                          ect\513\hit_wsn_2.0\Projects\zstack\Samples\Router #
#                          _v2\CC2430DB\..\..\..\..\..\COMPONENTS\SERVICES\SA #
#                          DDR\" -I "C:\Documents and                         #
#                          Settings\Administrator\×ÀÃæ\project\513\hit_wsn_2. #
#                          0\Projects\zstack\Samples\Router_v2\CC2430DB\..\.. #
#                          \..\..\..\COMPONENTS\SERVICES\SDATA\" -I           #
#                          "C:\Documents and Settings\Administrator\×ÀÃæ\proj #
#                          ect\513\hit_wsn_2.0\Projects\zstack\Samples\Router #
#                          _v2\CC2430DB\..\..\..\..\..\COMPONENTS\MAC\INCLUDE #
#                          \" -I "C:\Documents and Settings\Administrator\×ÀÃ #
#                          æ\project\513\hit_wsn_2.0\Projects\zstack\Samples\ #
#                          Router_v2\CC2430DB\..\..\..\..\..\COMPONENTS\MAC\H #
#                          IGH_LEVEL\" -I "C:\Documents and                   #
#                          Settings\Administrator\×ÀÃæ\project\513\hit_wsn_2. #
#                          0\Projects\zstack\Samples\Router_v2\CC2430DB\..\.. #
#                          \..\..\..\COMPONENTS\MAC\LOW_LEVEL\SRF03\" -I      #
#                          "C:\Documents and Settings\Administrator\×ÀÃæ\proj #
#                          ect\513\hit_wsn_2.0\Projects\zstack\Samples\Router #
#                          _v2\CC2430DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LEV #
#                          EL\SRF03\SINGLE_CHIP\" -I "C:\Program Files\IAR    #
#                          Systems\Embedded Workbench 4.0 Evaluation          #
#                          version\8051\INC\" -I "C:\Program Files\IAR        #
#                          Systems\Embedded Workbench 4.0 Evaluation          #
#                          version\8051\INC\CLIB\"                            #
#    List file          =  C:\Documents and Settings\Administrator\×ÀÃæ\proje #
#                          ct\513\hit_wsn_2.0\Projects\zstack\Samples\Router_ #
#                          v2\CC2430DB\RouterEB\List\SPIMgr.lst               #
#    Object file        =  C:\Documents and Settings\Administrator\×ÀÃæ\proje #
#                          ct\513\hit_wsn_2.0\Projects\zstack\Samples\Router_ #
#                          v2\CC2430DB\RouterEB\Obj\SPIMgr.r51                #
#                                                                             #
#                                                                             #
###############################################################################

C:\Documents and Settings\Administrator\×ÀÃæ\project\513\hit_wsn_2.0\Components\mt\SPIMgr.c
      1          /**************************************************************************************************
      2            Filename:       SPIMgr.c
      3            Revised:        $Date: 2007-10-28 18:43:04 -0700 (Sun, 28 Oct 2007) $
      4            Revision:       $Revision: 15800 $
      5          
      6            Description:    This module handles anything dealing with the serial port.
      7          
      8          
      9            Copyright 2005-2007 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, 
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com. 
     38          **************************************************************************************************/
     39          
     40          /***************************************************************************************************
     41           *                                           INCLUDES
     42           ***************************************************************************************************/
     43          #include "ZComDef.h"
     44          #include "OSAL.h"
     45          #include "hal_uart.h"
     46          #include "MTEL.h"
     47          #include "SPIMgr.h"
     48          #include "OSAL_Memory.h"
     49          
     50          /***************************************************************************************************
     51           *                                            MACROS
     52           ***************************************************************************************************/
     53          
     54          /***************************************************************************************************
     55           *                                           CONSTANTS
     56           ***************************************************************************************************/
     57          
     58          /* State values for ZTool protocal */
     59          #define SOP_STATE      0x00
     60          #define CMD_STATE1     0x01
     61          #define CMD_STATE2     0x02
     62          #define LEN_STATE      0x03
     63          #define DATA_STATE     0x04
     64          #define FCS_STATE      0x05
     65          
     66          /***************************************************************************************************
     67           *                                            TYPEDEFS
     68           ***************************************************************************************************/
     69          
     70          /***************************************************************************************************
     71           *                                         GLOBAL VARIABLES
     72           ***************************************************************************************************/

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     73          byte App_TaskID;
   \                     App_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     74          
     75          /* ZTool protocal parameters */
     76          
     77          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     78          uint8 state;
   \                     state:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     79          uint8  CMD_Token[2];
   \                     CMD_Token:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     80          uint8  LEN_Token;
   \                     LEN_Token:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     81          uint8  FSC_Token;
   \                     FSC_Token:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     82          mtOSALSerialData_t  *SPI_Msg;
   \                     SPI_Msg:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     83          uint8  tempDataLen;
   \                     tempDataLen:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     84          #endif //ZTOOL
     85          
     86          #if defined (ZAPP_P1) || defined (ZAPP_P2)
     87          uint16  SPIMgr_MaxZAppBufLen;
     88          bool    SPIMgr_ZAppRxStatus;
     89          #endif
     90          
     91          //------------------------------------------------------------------------------
     92          // xiaoyang add
     93          //------------------------------------------------------------------------------
     94          extern byte data_trans_TaskID;
     95          
     96          
     97          /***************************************************************************************************
     98           *                                          LOCAL FUNCTIONS
     99           ***************************************************************************************************/
    100          
    101          /***************************************************************************************************
    102           * @fn      SPIMgr_Init
    103           *
    104           * @brief
    105           *
    106           * @param   None
    107           *
    108           * @return  None
    109          ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    110          void SPIMgr_Init ()
   \                     SPIMgr_Init:
    111          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 29
   \   000004   74E3         MOV     A,#-0x1d
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
    112            halUARTCfg_t uartConfig;
    113          
    114            /* Initialize APP ID */
    115            App_TaskID = 0;
   \   000009   E4           CLR     A
   \   00000A   90....       MOV     DPTR,#App_TaskID
   \   00000D   F0           MOVX    @DPTR,A
    116          
    117            /* UART Configuration */
    118            uartConfig.configured           = TRUE;
   \   00000E   7401         MOV     A,#0x1
   \   000010   85..82       MOV     DPL,?XSP + 0
   \   000013   85..83       MOV     DPH,?XSP + 1
   \   000016   F0           MOVX    @DPTR,A
    119            uartConfig.baudRate             = SPI_MGR_DEFAULT_BAUDRATE;
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   7403         MOV     A,#0x3
   \   00001C   F0           MOVX    @DPTR,A
    120            uartConfig.flowControl          = SPI_MGR_DEFAULT_OVERFLOW;
   \   00001D   7402         MOV     A,#0x2
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   E4           CLR     A
   \   000023   F0           MOVX    @DPTR,A
    121            uartConfig.flowControlThreshold = SPI_MGR_DEFAULT_THRESHOLD;
   \   000024   7403         MOV     A,#0x3
   \   000026   12....       LCALL   ?XSTACK_DISP0_8
   \   000029   7430         MOV     A,#0x30
   \   00002B   F0           MOVX    @DPTR,A
   \   00002C   A3           INC     DPTR
   \   00002D   E4           CLR     A
   \   00002E   F0           MOVX    @DPTR,A
    122            uartConfig.rx.maxBufSize        = SPI_MGR_DEFAULT_MAX_RX_BUFF;
   \   00002F   740A         MOV     A,#0xa
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   7480         MOV     A,#-0x80
   \   000036   F0           MOVX    @DPTR,A
   \   000037   A3           INC     DPTR
   \   000038   E4           CLR     A
   \   000039   F0           MOVX    @DPTR,A
    123            uartConfig.tx.maxBufSize        = SPI_MGR_DEFAULT_MAX_TX_BUFF;
   \   00003A   7412         MOV     A,#0x12
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   7480         MOV     A,#-0x80
   \   000041   F0           MOVX    @DPTR,A
   \   000042   A3           INC     DPTR
   \   000043   E4           CLR     A
   \   000044   F0           MOVX    @DPTR,A
    124            uartConfig.idleTimeout          = SPI_MGR_DEFAULT_IDLE_TIMEOUT;
   \   000045   7405         MOV     A,#0x5
   \   000047   12....       LCALL   ?XSTACK_DISP0_8
   \   00004A   7406         MOV     A,#0x6
   \   00004C   F0           MOVX    @DPTR,A
    125            uartConfig.intEnable            = TRUE;
   \   00004D   7416         MOV     A,#0x16
   \   00004F   12....       LCALL   ?XSTACK_DISP0_8
   \   000052   7401         MOV     A,#0x1
   \   000054   F0           MOVX    @DPTR,A
    126          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
    127            uartConfig.callBackFunc         = SPIMgr_ProcessZToolData;
   \   000055   741B         MOV     A,#0x1b
   \   000057   12....       LCALL   ?XSTACK_DISP0_8
   \   00005A   74..         MOV     A,#(??SPIMgr_ProcessZToolData?relay & 0xff)
   \   00005C   F0           MOVX    @DPTR,A
   \   00005D   A3           INC     DPTR
   \   00005E   74..         MOV     A,#((??SPIMgr_ProcessZToolData?relay >> 8) & 0xff)
   \   000060   F0           MOVX    @DPTR,A
    128          #elif defined (ZAPP_P1) || defined (ZAPP_P2)
    129            uartConfig.callBackFunc         = SPIMgr_ProcessZAppData;
    130          #else
    131            uartConfig.callBackFunc         = NULL;
    132          #endif
    133          
    134            /* Start UART */
    135          #if defined (SPI_MGR_DEFAULT_PORT)
    136            HalUARTOpen (SPI_MGR_DEFAULT_PORT, &uartConfig);
   \   000061                ; Setup parameters for call to function HalUARTOpen
   \   000061   85..82       MOV     DPL,?XSP + 0
   \   000064   85..83       MOV     DPH,?XSP + 1
   \   000067   AA82         MOV     R2,DPL
   \   000069   AB83         MOV     R3,DPH
   \   00006B   7900         MOV     R1,#0x0
   \   00006D   12....       LCALL   ??HalUARTOpen?relay
    137          #else
    138            /* Silence IAR compiler warning */
    139            (void)uartConfig;
    140          #endif
    141          
    142            /* Initialize for ZApp */
    143          #if defined (ZAPP_P1) || defined (ZAPP_P2)
    144            /* Default max bytes that ZAPP can take */
    145            SPIMgr_MaxZAppBufLen  = 1;
    146            SPIMgr_ZAppRxStatus   = SPI_MGR_ZAPP_RX_READY;
    147          #endif
    148          
    149          
    150          }
   \   000070   741D         MOV     A,#0x1d
   \   000072   12....       LCALL   ?DEALLOC_XSTACK8
   \   000075                REQUIRE ?Subroutine0
   \   000075                ; // Fall through to label ?Subroutine0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    151          
    152          /***************************************************************************************************
    153           * @fn      MT_SerialRegisterTaskID
    154           *
    155           * @brief
    156           *
    157           *   This function registers the taskID of the application so it knows
    158           *   where to send the messages whent they come in.
    159           *
    160           * @param   void
    161           *
    162           * @return  void
    163           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    164          void SPIMgr_RegisterTaskID( byte taskID )
   \                     SPIMgr_RegisterTaskID:
    165          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    166            App_TaskID = taskID;
   \   000004   E9           MOV     A,R1
   \   000005   90....       MOV     DPTR,#App_TaskID
   \   000008   F0           MOVX    @DPTR,A
    167          }
   \   000009   80..         SJMP    ?Subroutine0
    168          
    169          /***************************************************************************************************
    170           * @fn      SPIMgr_CalcFCS
    171           *
    172           * @brief
    173           *
    174           *   Calculate the FCS of a message buffer by XOR'ing each byte.
    175           *   Remember to NOT include SOP and FCS fields, so start at the CMD
    176           *   field.
    177           *
    178           * @param   byte *msg_ptr - message pointer
    179           * @param   byte len - length (in bytes) of message
    180           *
    181           * @return  result byte
    182           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    183          byte SPIMgr_CalcFCS( uint8 *msg_ptr, uint8 len )
   \                     SPIMgr_CalcFCS:
    184          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FC           MOV     R4,A
    185            byte x;
    186            byte xorResult;
    187          
    188            xorResult = 0;
   \   000007   7900         MOV     R1,#0x0
    189          
    190            for ( x = 0; x < len; x++, msg_ptr++ )
   \   000009   7D00         MOV     R5,#0x0
   \   00000B   800E         SJMP    ??SPIMgr_CalcFCS_0
    191              xorResult = xorResult ^ *msg_ptr;
   \                     ??SPIMgr_CalcFCS_1:
   \   00000D   8A82         MOV     DPL,R2
   \   00000F   8B83         MOV     DPH,R3
   \   000011   E0           MOVX    A,@DPTR
   \   000012   C9           XCH     A,R1
   \   000013   69           XRL     A,R1
   \   000014   F9           MOV     R1,A
   \   000015   0D           INC     R5
   \   000016   A3           INC     DPTR
   \   000017   AA82         MOV     R2,DPL
   \   000019   AB83         MOV     R3,DPH
   \                     ??SPIMgr_CalcFCS_0:
   \   00001B   ED           MOV     A,R5
   \   00001C   C3           CLR     C
   \   00001D   9C           SUBB    A,R4
   \   00001E   40ED         JC      ??SPIMgr_CalcFCS_1
    192          
    193            return ( xorResult );
   \   000020   7F01         MOV     R7,#0x1
   \   000022   02....       LJMP    ?BANKED_LEAVE_XDATA
    194          }
    195          
    196          
    197          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
    198          /***************************************************************************************************
    199           * @fn      SPIMgr_ProcessZToolRxData
    200           *
    201           * @brief   | SOP | CMD  |   Data Length   | FSC  |
    202           *          |  1  |  2   |       1         |  1   |
    203           *
    204           *          Parses the data and determine either is SPI or just simply serial data
    205           *          then send the data to correct place (MT or APP)
    206           *
    207           * @param   pBuffer  - pointer to the buffer that contains the data
    208           *          length   - length of the buffer
    209           *
    210           *
    211           * @return  None
    212           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    213          void SPIMgr_ProcessZToolData ( uint8 port, uint8 event )
   \                     SPIMgr_ProcessZToolData:
    214          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    215            /*
    216            uint8  ch;
    217          
    218            // Verify events 
    219            if (event == HAL_UART_TX_FULL)
    220            {
    221              // Do something when TX if full
    222              return;
    223            }
    224          
    225            if (event & (HAL_UART_RX_FULL | HAL_UART_RX_ABOUT_FULL | HAL_UART_RX_TIMEOUT))
    226            {
    227              while (Hal_UART_RxBufLen(SPI_MGR_DEFAULT_PORT))
    228              {
    229                HalUARTRead (SPI_MGR_DEFAULT_PORT, &ch, 1);
    230          
    231                switch (state)
    232                {
    233                  case SOP_STATE:
    234                    if (ch == SOP_VALUE)
    235                      state = CMD_STATE1;
    236                    break;
    237          
    238                  case CMD_STATE1:
    239                    CMD_Token[0] = ch;
    240                    state = CMD_STATE2;
    241                    break;
    242          
    243                  case CMD_STATE2:
    244                    CMD_Token[1] = ch;
    245                    state = LEN_STATE;
    246                    break;
    247          
    248                  case LEN_STATE:
    249                    LEN_Token = ch;
    250                    if (ch == 0)
    251                      state = FCS_STATE;
    252                    else
    253                      state = DATA_STATE;
    254          
    255                    tempDataLen = 0;
    256          
    257                    //Allocate memory for the data 
    258                    SPI_Msg = (mtOSALSerialData_t *)osal_msg_allocate( sizeof ( mtOSALSerialData_t ) + 2+1+LEN_Token );
    259          
    260                    if (SPI_Msg)
    261                    {
    262                      //Fill up what we can 
    263                      SPI_Msg->hdr.event = CMD_SERIAL_MSG;
    264                      SPI_Msg->msg = (uint8*)(SPI_Msg+1);
    265                      SPI_Msg->msg[0] = CMD_Token[0];
    266                      SPI_Msg->msg[1] = CMD_Token[1];
    267                      SPI_Msg->msg[2] = LEN_Token;
    268                    }
    269                    else
    270                    {
    271                      state = SOP_STATE;
    272                      return;
    273                    }
    274          
    275                    break;
    276          
    277                  case DATA_STATE:
    278                      SPI_Msg->msg[3 + tempDataLen++] = ch;
    279                      if ( tempDataLen == LEN_Token )
    280                        state = FCS_STATE;
    281                    break;
    282          
    283                  case FCS_STATE:
    284          
    285                    FSC_Token = ch;
    286          
    287                    // Make sure it's correct
    288                    if ((SPIMgr_CalcFCS ((uint8*)&SPI_Msg->msg[0], 2 + 1 + LEN_Token) == FSC_Token))
    289                    {
    290                      osal_msg_send( MT_TaskID, (byte *)SPI_Msg );
    291                    }
    292                    else
    293                    {
    294                      //deallocate the msg 
    295                      osal_msg_deallocate ( (uint8 *)SPI_Msg);
    296                    }
    297          
    298                    //Reset the state, send or discard the buffers at this point 
    299                    state = SOP_STATE;
    300          
    301                    break;
    302          
    303                  default:
    304                   break;
    305                }
    306          
    307          
    308              }
    309            }
    310            */
    311            osal_start_timerEx( data_trans_TaskID, 5,0); //Æô¶¯´®¿ÚÈÎÎñ
   \   000004                ; Setup parameters for call to function osal_start_timerEx
   \   000004   7C00         MOV     R4,#0x0
   \   000006   7D00         MOV     R5,#0x0
   \   000008   7A05         MOV     R2,#0x5
   \   00000A   7B00         MOV     R3,#0x0
   \   00000C   90....       MOV     DPTR,#data_trans_TaskID
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   F9           MOV     R1,A
   \   000011   12....       LCALL   ??osal_start_timerEx?relay
    312          }
   \   000014   80..         SJMP    ?Subroutine0

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??SPIMgr_Init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    SPIMgr_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??SPIMgr_RegisterTaskID?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    SPIMgr_RegisterTaskID

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??SPIMgr_CalcFCS?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    SPIMgr_CalcFCS

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??SPIMgr_ProcessZToolData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    SPIMgr_ProcessZToolData
    313          #endif //ZTOOL
    314          
    315          #if defined (ZAPP_P1) || defined (ZAPP_P2)
    316          /***************************************************************************************************
    317           * @fn      SPIMgr_ProcessZAppRxData
    318           *
    319           * @brief   | SOP | CMD  |   Data Length   | FSC  |
    320           *          |  1  |  2   |       1         |  1   |
    321           *
    322           *          Parses the data and determine either is SPI or just simply serial data
    323           *          then send the data to correct place (MT or APP)
    324           *
    325           * @param   pBuffer  - pointer to the buffer that contains the data
    326           *          length   - length of the buffer
    327           *
    328           *
    329           * @return  None
    330           ***************************************************************************************************/
    331          void SPIMgr_ProcessZAppData ( uint8 port, uint8 event )
    332          {
    333          //xianyang modified
    334            //osal_event_hdr_t  *msg_ptr;
    335            uint16 length = 0;
    336            uint16 rxBufLen  = Hal_UART_RxBufLen(SPI_MGR_DEFAULT_PORT);
    337          
    338            /*
    339               If maxZAppBufferLength is 0 or larger than current length
    340               the entire length of the current buffer is returned.
    341            */
    342            if ((SPIMgr_MaxZAppBufLen != 0) && (SPIMgr_MaxZAppBufLen <= rxBufLen))
    343            {
    344              length = SPIMgr_MaxZAppBufLen;
    345            }
    346            else
    347            {
    348              length = rxBufLen;
    349            }
    350          
    351            /* Verify events */
    352            if (event == HAL_UART_TX_FULL)
    353            {
    354              // Do something when TX if full
    355              return;
    356            }
    357          
    358            if (event & ( HAL_UART_RX_FULL | HAL_UART_RX_ABOUT_FULL | HAL_UART_RX_TIMEOUT))
    359            {
    360              if ( App_TaskID )
    361              {
    362                /*
    363                   If Application is ready to receive and there is something
    364                   in the Rx buffer then send it up
    365                */
    366                if ((SPIMgr_ZAppRxStatus == SPI_MGR_ZAPP_RX_READY ) && (length != 0))
    367                {
    368                  /* Disable App flow control until it processes the current data */
    369                   SPIMgr_AppFlowControl ( SPI_MGR_ZAPP_RX_NOT_READY );//¹Ø±ÕÁ÷
    370          
    371                  /* 2 more bytes are added, 1 for CMD type, other for length */
    372                  /*
    373                  msg_ptr = (osal_event_hdr_t *)osal_msg_allocate( length + sizeof(osal_event_hdr_t) );
    374                  if ( msg_ptr )
    375                  {
    376                    msg_ptr->event = SPI_INCOMING_ZAPP_DATA;
    377                    msg_ptr->status = length;
    378          
    379                    // Read the data of Rx buffer 
    380                    HalUARTRead( SPI_MGR_DEFAULT_PORT, (uint8 *)(msg_ptr + 1), length );
    381          
    382                    Send the raw data to application...or where ever 
    383                    osal_msg_send( App_TaskID, (uint8 *)msg_ptr );
    384                  }
    385                   */
    386                     osal_start_timerEx (data_trans_TaskID, 5, 250); //250msºóÖ´ÐÐdata_trans_process,5ÎªÃüÁî£¬×ÔÐÐ¶¨Òå
    387                   //ÕâÑùÃ¿µ±´®¿ÚÓÐÊý¾Ýµ½Ê±¾Í»áÆô¶¯¸ÃÈÎÎñ¡£
    388                }
    389              }
    390            }
    391          }
    392          
    393          /***************************************************************************************************
    394           * @fn      SPIMgr_ZAppBufferLengthRegister
    395           *
    396           * @brief
    397           *
    398           * @param   maxLen - Max Length that the application wants at a time
    399           *
    400           * @return  None
    401           *
    402           ***************************************************************************************************/
    403          void SPIMgr_ZAppBufferLengthRegister ( uint16 maxLen )
    404          {
    405            /* If the maxLen is larger than the RX buff, something is not right */
    406            if (maxLen <= SPI_MGR_DEFAULT_MAX_RX_BUFF)
    407              SPIMgr_MaxZAppBufLen = maxLen;
    408            else
    409              SPIMgr_MaxZAppBufLen = 1; /* default is 1 byte */
    410          }
    411          
    412          /***************************************************************************************************
    413           * @fn      SPIMgr_AppFlowControl
    414           *
    415           * @brief
    416           *
    417           * @param   status - ready to send or not
    418           *
    419           * @return  None
    420           *
    421           ***************************************************************************************************/
    422          void SPIMgr_AppFlowControl ( bool status )
    423          {
    424          
    425            /* Make sure only update if needed */
    426            if (status != SPIMgr_ZAppRxStatus )
    427            {
    428              SPIMgr_ZAppRxStatus = status;
    429            }
    430          
    431            /* App is ready to read again, ProcessZAppData have to be triggered too */
    432            if (status == SPI_MGR_ZAPP_RX_READY)
    433            {
    434              SPIMgr_ProcessZAppData ( SPI_MGR_DEFAULT_PORT, HAL_UART_RX_TIMEOUT );
    435            }
    436          
    437          }
    438          
    439          #endif //ZAPP
    440          
    441          /***************************************************************************************************
    442          ***************************************************************************************************/

   Maximum stack usage in bytes:

     Function                ISTACK PSTACK XSTACK
     --------                ------ ------ ------
     SPIMgr_CalcFCS              0      0      9
     SPIMgr_Init                 3      0     29
       -> HalUARTOpen            4      0     58
     SPIMgr_ProcessZToolData     2      0      0
       -> osal_start_timerEx     4      0      0
     SPIMgr_RegisterTaskID       2      0      0


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     App_TaskID                        1
     state                             1
     CMD_Token                         2
     LEN_Token                         1
     FSC_Token                         1
     SPI_Msg                           2
     tempDataLen                       1
     SPIMgr_Init                     117
     ?Subroutine0                      7
     SPIMgr_RegisterTaskID            11
     SPIMgr_CalcFCS                   37
     SPIMgr_ProcessZToolData          22
     ??SPIMgr_Init?relay               6
     ??SPIMgr_RegisterTaskID?relay     6
     ??SPIMgr_CalcFCS?relay            6
     ??SPIMgr_ProcessZToolData?relay
                                       6

 
 194 bytes in segment BANKED_CODE
  24 bytes in segment BANK_RELAYS
   9 bytes in segment XDATA_Z
 
 218 bytes of CODE  memory
   9 bytes of XDATA memory

Errors: none
Warnings: none
